[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Taller de programación R - SERNANP",
    "section": "",
    "text": "1 Presentación\nEl SERNANP brinda el servicio de mantener áreas protegidas en buen estado de conservación para asegurar la provisión de servicios ambientales que generen bienestar a poblaciones. Uno de los pilares para alcanzar dicha eficiencia es gestionar la información espacial generada en el interior de las áreas, así como información externa de aliados estratégicos y demás instiuciones que contribuyen al desarrollo del medio ambiente.\nEste taller tiene el objetivo de servir como herramienta para la gestión de información y pueda ser insumo para la toma de decisiones que lleven a implementar acciones con el fin de contribuir con el mantenimiento del buen estado de conservación de las ANP."
  },
  {
    "objectID": "c01_introduccion.html#lenguajes-de-programación",
    "href": "c01_introduccion.html#lenguajes-de-programación",
    "title": "2  Introducción a los lenguajes de programación",
    "section": "2.1 Lenguajes de programación",
    "text": "2.1 Lenguajes de programación\nUn lenguaje de programación es una forma de comunicarnos con una computadora e indicarle qué queremos hacer. En otras palabras, nos permitirá darle instrucciones y reglas que permiten crear herramientas, programas, realizar análisis o tareas específicas.\nExisten distintos tipos de lenguaje, según la conexión entre el software y hardware podemos diferenciarlos en lenguajes bajo nivel y de alto nivel. La diferencia se encuentra en lo cerca o lejos que estemos del hardware de nuestro equipo.\nAdemás, podemos diferenciarlos según el propósito o el modo de uso, aquellos que están orientados al desarrollo y aquellos que están orientados al análisis. Los lenguajes orientados al desarrollo se utilizan para crear aplicaciones y programas, mientras que los lenguajes orientados al análisis se utilizan para procesar y analizar datos.\n\n\n\nLenguajes de programación"
  },
  {
    "objectID": "c01_introduccion.html#interfaz-de-desarrollo-integrado-ide-y-editor-de-texto",
    "href": "c01_introduccion.html#interfaz-de-desarrollo-integrado-ide-y-editor-de-texto",
    "title": "2  Introducción a los lenguajes de programación",
    "section": "2.2 Interfaz de Desarrollo Integrado (IDE) y editor de texto",
    "text": "2.2 Interfaz de Desarrollo Integrado (IDE) y editor de texto\n\n\n\nIDEs y editores de texto"
  },
  {
    "objectID": "c01_introduccion.html#qué-es-r",
    "href": "c01_introduccion.html#qué-es-r",
    "title": "2  Introducción a los lenguajes de programación",
    "section": "2.3 ¿Qué es R?",
    "text": "2.3 ¿Qué es R?\nR es un lenguaje de programación y entorno computacional dedicado a la estadística que proporciona un amplio abanico de herramientas estadísticas (modelos lineales y no lineales, tests estadísticos, análisis de series temporales, algoritmos de clasificación y agrupamiento, etc.)\nPermite definir funciones propias. De hecho, gran parte de las funciones de R están escritas en el mismo R, aunque para algoritmos computacionalmente exigentes es posible desarrollar bibliotecas en C, C++ o Fortran que se cargan dinámicamente.\nR puede integrarse con distintas bases de datos y existen bibliotecas que facilitan su utilización desde lenguajes de programación interpretados como Python (PythonInR), hereda de S su orientación a objetos.\nOtra de las características de R es su capacidad gráfica, que permite generar gráficos con alta calidad (ggplot). R posee su propio formato para la documentación basado en LaTeX."
  },
  {
    "objectID": "c01_introduccion.html#qué-es-rstudio",
    "href": "c01_introduccion.html#qué-es-rstudio",
    "title": "2  Introducción a los lenguajes de programación",
    "section": "2.4 ¿Qué es RStudio?",
    "text": "2.4 ¿Qué es RStudio?\nRStudio es un editor para scripts disponible para usuarios de R en todos los sistemas operativos. Es considerado como un entorno de desarrollo integrado (GUI)que combina un interfaz muy intuitiva con herramientas de código muy potentes que permiten sacar el máximo provecho a R.\nLa ventaja de este editor es que ofrece una serie de opciones no existentes en R, entre otras, por ejemplo, comprobar rápidamente que ningún paréntesis queda sin cerrarse o marcar, copiar y pegar columnas.\nPero además nos da un listado de las variables y nos da una descripción de los bancos de datos que hemos introducido. También tiene una lista de los paquetes instalados y los gráficos realizados."
  },
  {
    "objectID": "c01_introduccion.html#qué-otros-ides-existen-para-r",
    "href": "c01_introduccion.html#qué-otros-ides-existen-para-r",
    "title": "2  Introducción a los lenguajes de programación",
    "section": "2.5 ¿Qué otros IDE’s existen para R?",
    "text": "2.5 ¿Qué otros IDE’s existen para R?\n\nTinn-R\nRKward\nRcommander\nJupyter notebook\nVisual studio code\nPycharm\nEclipse"
  },
  {
    "objectID": "c01_introduccion.html#instalación-de-r-rstudio-y-rtools",
    "href": "c01_introduccion.html#instalación-de-r-rstudio-y-rtools",
    "title": "2  Introducción a los lenguajes de programación",
    "section": "2.6 Instalación de R, RStudio y RTools",
    "text": "2.6 Instalación de R, RStudio y RTools\n\n2.6.1 R y RStudio\nPrimero deberá descargar e instalar R y luego RStudio.\nInstalación de R\nPara instalar R hay que bajar un fichero ejecutable de la página web del proyecto R: http://www.r-project.org/. Actualmente (Marzo 2023), la versión más reciente de R para el entorno Windows es la 4.2.3 y el ejecutable de tamaño aproximadamente 77Mb tiene el nombre R-4.2.3-win.exe.\nInstalación de RStudio\nPara instalar RStudio nos dirigimos al enlace http://www.rstudio.org/,la versión en pruebas es gratuita.Una vez bajado este ejecutable, hay que ejecutarlo y seguir las instrucciones del programa de instalación.\n\n\n2.6.2 RTools\nEs un paquete de herramientas para construir paquetes de R. Esto es lo que desea para construir sus propios paquetes en Windows, o para construir R por sí mismo. A partir de R 4.3.0 (2023), R para Windows usa un paquete de cadena de herramientas llamado rtools43.\nEsta versión de Rtools incluye gcc 8.3.0 e introduce un nuevo sistema de compilación basado en msys2`, que facilita la compilación y el mantenimiento de R, así como las bibliotecas del sistema que necesitan los paquetes de R en Windows. Las compilaciones recientes de rtools43 también contienen una cadena de herramientas adicional gcc-10 ucrt para probar paquetes de R y bibliotecas del sistema con las compilaciones ucrt experimentales de R-devel."
  },
  {
    "objectID": "c01_introduccion.html#tipos-de-lenguajes-de-programación",
    "href": "c01_introduccion.html#tipos-de-lenguajes-de-programación",
    "title": "2  Introducción a los lenguajes de programación",
    "section": "2.7 Tipos de lenguajes de programación",
    "text": "2.7 Tipos de lenguajes de programación\n\n2.7.1 Lenguaje compilado\nSon aquellos lenguajes de alto nivel que como su nombre lo sugiere, requieren de un compilador (programa que traduce un lenguaje de alto nivel en código máquina o lenguaje máquina) para traducirlo y crear la parte ejecutable.\n\nC++\nGo\n\n\n\n2.7.2 Lenguaje interpretado\nSon aquellos lenguajes de programación también de alto nivel en donde el código fuente debe ser traducido a un lenguaje que la máquina entienda y pueda realizar, no crean un archivo externo.\n\nRuby\nJavascript\nPython\nR\n\nLos lenguajes de alto nivel permiten escribir instrucciones en un idioma muy parecido al inglés así como hacer uso de notaciones matemáticas comunes.\n\n\n2.7.3 Lenguaje intermedio\nLos lenguajes intermedios son compilados hacia programas intermedios y luego interpretados, esto permite que pueda ser ejecutado desde cualquier sistema operativo sin necesidad de crear ejecutables.\n\nJava\nC#"
  },
  {
    "objectID": "c01_introduccion.html#paradigmas-de-programación",
    "href": "c01_introduccion.html#paradigmas-de-programación",
    "title": "2  Introducción a los lenguajes de programación",
    "section": "2.8 Paradigmas de programación",
    "text": "2.8 Paradigmas de programación\nUn paradigma de programación es una manera o estilo de programación de software. Se trata de un conjunto de métodos sistemáticos aplicables en todos los niveles del diseño de programas para resolver problemas computacionales.\n\n2.8.1 Programación Orientado a Objetos\nSe construyen modelos de objetos que representan elementos (objetos) del problema a resolver, que tienen características y funciones. Permite separar los diferentes componentes de un programa, simplificando así su creación, depuración y posteriores mejoras. La programación orientada a objetos disminuye los errores y promociona la reutilización del código. Es una manera especial de programar, que se acerca de alguna manera a cómo expresaríamos las cosas en la vida real.\n\n\n2.8.2 Programación Funcional\nLa programación funcional es un paradigma declarativo. Nos enfocaremos en “qué” estamos haciendo y no en “cómo” se está haciendo que sería el enfoque imperativo. Esto quiere decir que se expresa nuestra lógica sin describir controles de flujo, ni ciclos ni condicionales."
  },
  {
    "objectID": "c02_intro_R.html#ambiente-de-trabajo-en-rstudio",
    "href": "c02_intro_R.html#ambiente-de-trabajo-en-rstudio",
    "title": "3  Primeros pasos en R",
    "section": "3.1 Ambiente de trabajo en RStudio",
    "text": "3.1 Ambiente de trabajo en RStudio\nLa interfaz gráfica de RStudio nos permite acceder a scripts, datos, encontrar ayuda y previsualizar gráficos y resultados."
  },
  {
    "objectID": "c02_intro_R.html#tipos-de-datos-en-r",
    "href": "c02_intro_R.html#tipos-de-datos-en-r",
    "title": "3  Primeros pasos en R",
    "section": "3.2 Tipos de datos en R",
    "text": "3.2 Tipos de datos en R\nR es capaz de manejar una variedad de tipos de datos, que se almacenan en diferentes estructuras como se puede observar en la siguiente tabla:\n\n\n\n\n\n\n\n\nTipos de Datos\nInformación\nDefinición\n\n\n\n\nNumeric\nDatos contenidos en el conjuntos de los números reales\nnum <- 3.14\n\n\nInteger\nDatos contenidos en el conjuntos de los números enteros\nint <- 3L\n\n\nCharacter\nDatos que soportan cadenas de caracteres\nchr <- \"hello world\"\n\n\nComplex\nDatos que soportan números complejos\ncomp <- 3+2i\n\n\nLogical\nDatos que sólo soportan valores lógicos de verdadero (T) o falso (F)\na <- 1; b <- 2; a < b\n\n\nFactor\nEste no es estrictamente un tipo de dato, pero vale la pena describirlo aquí. Una variable factor es una variable categórica. Los vectores de caracteres a menudo se almacenan como factores para explotar funciones para tratar datos categóricos. Por ejemplo, en análisis de regresión\nAplique as.factor() a un vector de caracteres o numéricos"
  },
  {
    "objectID": "c02_intro_R.html#estructuras-de-datos",
    "href": "c02_intro_R.html#estructuras-de-datos",
    "title": "3  Primeros pasos en R",
    "section": "3.3 Estructuras de datos",
    "text": "3.3 Estructuras de datos\n\n\n\n\n\n\n\n\nObjetos\nTipos\n¿Soporta varios tipos de datos en el mismo objeto?\n\n\n\n\nVector\nNumérico, carácter, complejo o lógico\nNo\n\n\nFactor\nNumérico o lógico\nNo\n\n\nArreglo\nNumérico, carácter, complejo o lógico\nNo\n\n\nMatriz\nNumérico, carácter, complejo o lógico\nNo\n\n\nData frame\nNumérico, carácter, complejo o lógico\nSí\n\n\nts\nNumérico, carácter, complejo o lógico\nSí\n\n\nLista\nNumérico, carácter, complejo, lógico, función, expresión, …\nSí"
  },
  {
    "objectID": "c02_intro_R.html#comience-a-codificar",
    "href": "c02_intro_R.html#comience-a-codificar",
    "title": "3  Primeros pasos en R",
    "section": "3.4 Comience a codificar",
    "text": "3.4 Comience a codificar\nComenzamos a codificar imprimiendo Hello worldy posteriormente asignando valores a un objeto\n\n\nCode\nprint(\"Hello world\")\n\n\n\n3.4.1 Asignación de objetos\n\n\nCode\nobj <- c(5, 2, 6, 58, 456, 56, 5)\nc(5, 2, 6, 58, 456, 56, 5) -> obj"
  },
  {
    "objectID": "c02_intro_R.html#conceptos-básicos-de-r",
    "href": "c02_intro_R.html#conceptos-básicos-de-r",
    "title": "3  Primeros pasos en R",
    "section": "3.5 Conceptos Básicos de R",
    "text": "3.5 Conceptos Básicos de R\n\n3.5.1 Espacio y directorio de trabajo\n\n\n\n\n\n\n\nFunción\nAcción\n\n\n\n\ngetwd()\nMuestra el wd: working directory\n\n\nsetwd(\"midirectorio\")\nAjusta el wd al especificado\n\n\nls()  o dir()\nLista lo que hay en el wd\n\n\nhistory()\nMuestra los últimos comandos ejecutados\n\n\nsavehistory()\nGuarda el historial de comandos, por defecto en .Rhistory\n\n\nloadhistory()\nCarga el historial de comandos\n\n\nsave.image(\"mywspace.R\")\nGuarda los objetos del workspace, por defecto en .Rdata\n\n\nload(\"mywspace.R\")\nCarga el workspace mywspace.R\n\n\n\n\n\n3.5.2 Vector\n\nEs el elemento más básico en R.\nContiene elementos de la misma clase (son atómicos).\nSe crea con la función c(), que significa ‘concatenar’ o ‘combinar’.\n\n\n\nCode\nvector01 <- c(1, 2, 4, 7, 10, 11, 12, 19, 26)\nvector02 <- c(\"a\", \"b\", \"d\", \"g\", \"j\", \"k\", \"l\", \"s\", \"z\")\nvector03 <- c(\"jorge\", \"roy\", \"daniel\", \"cesar\", \"patin\", 254, 265)\nvector04 <- c(FALSE, FALSE, FALSE, TRUE, TRUE, TRUE, TRUE)\n\n\nAlgunas operaciones con vectores\n\n\nCode\n# indexar vectores\nvector01\nvector01[4]\n# evaluar la naturaleza del vector\na <- vector01[4]\nis.vector(a)\nis.numeric(a)\nis.integer(a)\n# operaciones con vectores\nlength(vector01)\n(vector01 * 2) + 500\nsum(vector01)\nsqrt(vector01 - 1)\nvector01 + (vector01 * 2)\n\n\n\n\n3.5.3 Matrix\nUna matriz es una estructura bidimensional. Las filas son horizontales y las columnas son verticales. Una matriz de 4 por 3 (4 x 3), por ejemplo, tiene 4 filas y 3 columnas. Las matrices se crean comúnmente usando tablas de datos numéricos como las de una hoja de cálculo de Excel o un archivo csv.\n\n\nCode\nvector01\n\n\n[1]  1  2  4  7 10 11 12 19 26\n\n\nCode\ndim(vector01)\n\n\nNULL\n\n\nDado que la variable es un vector, no tiene un atributo dim (entonces es simplemente NULL).\n¿Qué ocurre si le damos a vector01 un atributo dim?\n\n\nCode\ndim(vector01) <- c(3, 3)\nclass(vector01)\n\n\n[1] \"matrix\" \"array\" \n\n\nEl ejemplo que utilizamos hasta ahora tenía la intención de ilustrar la idea de que una matriz es simplemente un vector con un atributo de dimensión.\nUn método más directo para crear la misma matriz utiliza la función matrix.\n\n\nCode\nmatrix01 <- matrix(vector01, nrow = 3, ncol = 3, byrow = T)\n\n\n\n\nCode\narboles <- c(\"Tipuana tipu\", \"Myrsine andina\", \"Salix humboldtiana\")\nmatrix02 <- cbind(arboles, matrix01) # column bind o juntar por columna.\n\n\nEsto se llama coerción implícita porque no lo hemos pedido. Solo sucedió. Sin embargo, todavía se desea trabajar con diferentes tipos de datos.\n\n\nCode\nclass(matrix02)\n\n\n[1] \"matrix\" \"array\" \n\n\nCode\ndim(matrix02)\n\n\n[1] 3 4\n\n\nCode\nrownames(matrix02)\n\n\nNULL\n\n\nCode\ncolnames(matrix02)\n\n\n[1] \"arboles\" \"\"        \"\"        \"\"       \n\n\n\n\n3.5.4 Data Frame\nUn data frame es una estructura de datos bidimensional similar a una matriz, pero funciona de manera muy diferente. Si bien un data frame parece una tabla simple, de hecho es una lista de vectores de la misma longitud. Las matrices y los data frames parecen similares, sin embargo, la principal diferencia es que un data frame permite tipos de datos mixtos (por ejemplo, numérico, lógico, caracter). Esto les permite almacenar diferentes tipos de variables, lo cual es muy útil en el análisis estadístico. Por ejemplo, en un análisis de regresión. Las matrices se usan principalmente para almacenar datos numéricos, y se pueden usar para álgebra matricial.\nMatrices y Data Frames, ambos representan tipos de datos rectangulares, lo que significa que se usan para almacenar datos tabulares, con filas y columnas.\nLa principal diferencia, es que las matrices solo pueden contener una única clase de datos (al igual que los vectores), mientras que los dataframes pueden consistir de muchas clases diferentes de datos.\n\n\nCode\n# se crea un data frame (df)\ndf01 <- data.frame(arboles, matrix01)\nclass(df01)\n\n\n[1] \"data.frame\"\n\n\nCode\n# podemos cambiar el nombre a las variables (columnas)\ncolnames(df01) <- c(\"nombre_cientifico\", \"circunferencia\", \"diametro_copa\", \"altura\" )\n\n\n\n3.5.4.1 Conjunto de datos en R\nVarios conjuntos de datos tabulados o datasets se icluyen en la instalación de R (en el paquete datasets) y por defecto se ecuentran cargados para su uso. la funcion data() lista todos los datasets de R.\nTrabajemos con el dataset iris (Edgar Anderson’s Iris Data)\n\n\nCode\nstr(iris)\n# todas las observaciones de la columna 'Species'\niris[, \"Species\"]\n# Se utiliza el caracter ‘$’ para acceder a los campos o columnas.\niris$Species\n\n\nCuando queremos extraer datos del data frame según una condicion, esto se complica.\n\n\nCode\nhead(iris[iris$Species == \"setosa\", ])\n\n\nAsí mismo, si se desea obtener las observaciones donde el ancho del sépalo sea menor o igual a 3 y la especie sea “setosa”.\n\n\nCode\nhead(iris[iris[, \"Sepal.Width\"] <= 3 & iris[, \"Species\"] == \"setosa\", ])\n\n\n\n\n3.5.4.2 Subsetting\nLa función subset nos facilita filtrar datos cuando queremos que se cumplan ciertas condiciones.\n\n\nCode\nsubset(iris, Sepal.Width <= 3 & Species == \"setosa\")\n\n\n¿Pero es la mejor opción? ¿Cómo ordeno? ¿Cómo cambio de un formato “ancho” a un formato “largo” (o viceversa)? etc.\nLa tendencia en la comunidad R para el tratamiento de datos, comprende el uso de tidyverse.\n\n\n\n3.5.5 Listas\nA diferencia de un vector, una lista es una colección de elementos que pueden ser de diferente tipo. Los componentes de una lista son típicamente pares clave-valor (key-value). El siguiente ejemplo muestra cómo se puede almacenar un punto (con coordenas) en una lista.\n\n\nCode\n# Los elementos de la lista generalmente se acceden por nombre\ncoordenadas <- list(x = 10, y = 15)\ncoordenadas\npoint <- list(id = 123, coord = coordenadas, spatial.reference = \"WGS_84\")\npoint\npoint$id\n# También podemos acceder a sus elementos de la siguiente manera\npoint[1]\nclass(point[1])\n# Para obtener el valor del elemento de la lista, use corchetes dobles\npoint[[1]]\nclass(point[[1]])\n\n\nLa lista, en el ejemplo, tiene tres elementos de diferentes tipos de datos. id es numérico, coord es otra lista y spatial.reference es una cadena de caracteres. La lista coord contiene dos elementos numéricos, x e y. Generalmente, se accede a los elementos de la lista usando su nombre, en lugar de número. En particular, muchas estructuras de datos tienen elementos con nombre a los que se puede acceder utilizando los operadores $ o @."
  },
  {
    "objectID": "c02_intro_R.html#lectura-escritura-de-datos-.csv-.xlsx-.rdata-.rds",
    "href": "c02_intro_R.html#lectura-escritura-de-datos-.csv-.xlsx-.rdata-.rds",
    "title": "3  Primeros pasos en R",
    "section": "3.6 Lectura / escritura de datos (.csv, .xlsx, .RData, .rds)",
    "text": "3.6 Lectura / escritura de datos (.csv, .xlsx, .RData, .rds)\nEn la pestaña en Entorno (Environment) de RStudio podemos importar conjuntos de datos o datasets con el asistente de importación. No es recomendable cuando debemos importar varios archivos o si se van a leer archivos grandes. Para lo cual es más eficiente usar código.\n\n\n3.6.1 CSV\nSi conocemos la estructura de nuestros datos (por ejemplo, la primera fila es el título de las columnas o es un archivo separado por comas), Se pueden utilizar las funciones read.csv (librería base) o read_csv (librería readr, de tidyverse):\n\n\nCode\n# datos será un 'data frame'\ndata01 <- read.csv(file = 'data/file.csv')\nhead(data01)\n\n\n  Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n1          5.1         3.5          1.4         0.2  setosa\n2          4.9         3.0          1.4         0.2  setosa\n3          4.7         3.2          1.3         0.2  setosa\n4          4.6         3.1          1.5         0.2  setosa\n5          5.0         3.6          1.4         0.2  setosa\n6          5.4         3.9          1.7         0.4  setosa\n\n\nCode\n# datos será un 'tibble'\ndata01 <- readr::read_csv(file = 'data/file.csv')\n\n\nRows: 150 Columns: 5\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (1): Species\ndbl (4): Sepal.Length, Sepal.Width, Petal.Length, Petal.Width\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n\nCode\ndata01\n\n\n# A tibble: 150 × 5\n   Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n          <dbl>       <dbl>        <dbl>       <dbl> <chr>  \n 1          5.1         3.5          1.4         0.2 setosa \n 2          4.9         3            1.4         0.2 setosa \n 3          4.7         3.2          1.3         0.2 setosa \n 4          4.6         3.1          1.5         0.2 setosa \n 5          5           3.6          1.4         0.2 setosa \n 6          5.4         3.9          1.7         0.4 setosa \n 7          4.6         3.4          1.4         0.3 setosa \n 8          5           3.4          1.5         0.2 setosa \n 9          4.4         2.9          1.4         0.2 setosa \n10          4.9         3.1          1.5         0.1 setosa \n# ℹ 140 more rows\n\n\nEn otros casos, cuando \";\" es utilizado como el separador de campo y \",\" para el punto decimal, se utiliza una variante de estas funciones.\n\n\nCode\n# datos será un 'data frame'\ndata02 <- read.csv(file = 'data/file.csv', sep = ',', header = T)\n\n\nLa escritura de datos se realiza de la siguiente manera:\n\n\nCode\nreadr::write_csv(x = data02, file = \"data/csv_data.csv\")\n\n\n\n\n3.6.2 EXCEL\nEs posible leer datos en la forma .xls o .xlsx. Existen distintos paquetes que nos permiten hacerlo:\n\nEl paquete readxl contiene la función read_excel.\nEl paquete xlsx y la función read.xlsx\n\n\n\nCode\n# datos será un 'data frame'\ndata03 <- readxl::read_xls(path = \"data/file.xls\", sheet = 1)\ndata03 <- xlsx::read.xlsx(file = \"data/file.xls\", 1)\n\n\nLa escritura de datos se realiza de la siguiente manera:\n\n\nCode\nxlsx::write.xlsx(\n  data03, \"data/xlsx_data.xlsx\", sheetName = \"Sheet1\", \n  col.names = TRUE, row.names = TRUE, append = FALSE\n)\n\n\n\n\n3.6.3 RDS\nR proporciona dos formatos de archivo propios para almacenar datos, .RDS y .RData . Los archivos RDS pueden almacenar un solo objeto R y los archivos RData pueden almacenar varios objetos R.\nPuede abrir un archivo RDS con readRDS:\n\n\nCode\ndata04 <- readRDS(\"data/file.RDS\")\n\n\nLa escritura de datos se realiza de la siguiente manera:\n\n\nCode\nsaveRDS(data04, file = \"data/rds_data.RDS\")\n\n\n\n\n3.6.4 RDATA\nLa escritura de estos datos se realiza de la siguiente manera:\n\n\nCode\na <- 1\nb <- 2\nc <- 3\nsave(a, b, c, file = \"data/stuff.RData\")\n\n\nPuede abrir un archivo RData con load:\n\n\nCode\nload(\"data/stuff.RData\")"
  },
  {
    "objectID": "c03_intro_R2.html#control-de-flujo-condicionales",
    "href": "c03_intro_R2.html#control-de-flujo-condicionales",
    "title": "4  Control de Flujo y funciones",
    "section": "4.1 Control de Flujo Condicionales",
    "text": "4.1 Control de Flujo Condicionales\nLa toma de decisiones es una parte importante de la programación. Esto se puede lograr en la programación R usando la nomenclatura condicional if else.\n\n4.1.1 If\n\n\nCode\nif (expresion) {\n  declaracion\n}\n\n\n\nSi expresion es TRUE, la instrucción se ejecuta. Pero si es FALSO, no pasa nada.\nAquí, expresion puede ser un vector lógico o numérico, pero solo se tiene en cuenta el primer elemento.\nEn el caso del vector numérico, cero se toma como FALSO, el resto como VERDADERO.\n\n\n\n4.1.2 If…Else\n\n\nCode\nif (expresion) {\n    declaracion1\n  }else{\n    declaracion2\n}\n\n\nLa parte else es opcional y solo se evalúa si expresion es FALSE. Es importante tener en cuenta que else debe estar en la misma línea que las llaves de cierre de la instrucción if.\n\n\nCode\nx <- 0\nif (x < 0) {\n  print(\"Numero negativo\")\n}else if (x > 0) {\n  print(\"Numero positivo\")\n} else {\n  print(\"Cero\")\n}\n\n\n\n\nCode\ntemp = [15, 22, 30]\nsuelo= [\"seco\", \"humedo\", \"charcos\"]\nvaltemp = temp[0]\nvalsuelo= suelo[2]\nif 12<= valtemp < 22 and valsuelo ==\"seco\": \n    print(\"Cielo despejado\")\n    \nelif valtemp == 22 or valsuelo == \"humedo\":\n    print(\"lluvia leve\")\n    \nelif valtemp > 22 and valsuelo==\"charcos\":\n      print(\"lluvia severa\")\n    \nelse: print(\" Faltan datos\")\n\n\n\n\nCode\ntemp <- c(15, 22, 30)\nsuelo <- c(\"seco\", \"humedo\", \"charcos\")\nvaltemp <- temp[1]\nvalsuelo <- suelo[3]\nif (valtemp %in% 12:22 & valsuelo ==\"seco\") {\n  print(\"\\nCielo despejado\")\n} else if (valtemp == 22 | valsuelo == \"humedo\"){\n  print(\"\\nlluvia leve\")\n} else if (valtemp > 22 & valsuelo==\"charcos\"){\n  print(\"\\nlluvia severa\")\n} else {\n  print(\"\\nFaltan datos\")\n  }"
  },
  {
    "objectID": "c03_intro_R2.html#control-de-flujo-de-iteradores",
    "href": "c03_intro_R2.html#control-de-flujo-de-iteradores",
    "title": "4  Control de Flujo y funciones",
    "section": "4.2 Control de Flujo de Iteradores",
    "text": "4.2 Control de Flujo de Iteradores\nLos bucles son una de las estructuras fundamentales en la programación. Los bucles permiten iterar sobre cada elemento en una secuencia, uno a la vez, y hacer algo con esos elementos.\n\n4.2.1 FOR\nUn bucle for es muy valioso cuando necesitamos iterar sobre una lista de elementos o un rango de números. Loop se puede usar para iterar sobre una lista, marco de datos, vector, matriz o cualquier otro objeto. Los tirantes y el corchete son obligatorios.\n\n\nCode\nfor (valor in secuencia)\n  {\n    cuerpo\n  }\n\n\n\n\nCode\n# Creando un vector de frutas\nfrutas <- c('Apple', 'Orange', 'Passion fruit', 'Banana')\n# Declarando el bucle for\nfor ( i in frutas){ \n print(i)\n}\n\n\n[1] \"Apple\"\n[1] \"Orange\"\n[1] \"Passion fruit\"\n[1] \"Banana\"\n\n\n\n\n4.2.2 WHILE\nUn bucle es una declaración que continúa ejecutándose mientras se cumple una condición. La sintaxis para un ciclo while es la siguiente:\n\n\nCode\nwhile (condición)\n  {\n    cuerpo\n  }\n\n\n\n\nCode\n# creando la expresión con valor 1\ninicio <- 1\n# Creando el loop\nwhile (inicio <= 5){\n  # Ver donde estamos\n  cat('Este es el ciclo número ', inicio)\n  # Agregar 1 a la variable inicio despues de cada iteracion\n  inicio <- inicio + 1\n  print(inicio)\n}\n\n\nEste es el ciclo número  1[1] 2\nEste es el ciclo número  2[1] 3\nEste es el ciclo número  3[1] 4\nEste es el ciclo número  4[1] 5\nEste es el ciclo número  5[1] 6\n\n\nOtros iteradores\n\nrepeat\ndo-while (*otros leguajes)\n\nControl de flujo * break, next"
  },
  {
    "objectID": "c03_intro_R2.html#funciones",
    "href": "c03_intro_R2.html#funciones",
    "title": "4  Control de Flujo y funciones",
    "section": "4.3 Funciones",
    "text": "4.3 Funciones\nLa noción de función está bastante de moda, pero transmite diferentes significados. Dos usos distintos:\n\nNoción matemática de una función: Proporcionar un mapeo entre conjuntos de elementos.\nUna explicación “funcional” explica un fenómeno natural en términos de sus objetivos o propósitos.\n\nEn programación, las funciones también proporcionan asignaciones, pero se las considera mejor como herramientas para resolver tareas. La programación de funciones requiere la identificación de tareas que se encontrarán y, por lo tanto, deben resolverse repetidamente (por nosotros mismos o por otros).\nLos argumentos de la función  especifican las entradas (o los datos, representados como objetos R) aceptados por una función. Cada argumento puede ser obligatorio u opcional (proporcionando valores predeterminados).\nEl  de la función generalmente usa las entradas proporcionadas por  para realizar la tarea para la cual se creó la función. Puede contener cantidades arbitrarias de código R (incluidas referencias a objetos R existentes y otras funciones). Por defecto, la función devuelve el resultado de su última expresión.\nAquí un ejemplo:\n\n\nCode\npower <- function(x, exp = 1) {\n  x^exp\n}"
  },
  {
    "objectID": "c03_intro_R2.html#paquetes-y-librerías",
    "href": "c03_intro_R2.html#paquetes-y-librerías",
    "title": "4  Control de Flujo y funciones",
    "section": "4.4 Paquetes y librerías",
    "text": "4.4 Paquetes y librerías\nLos paquetes de R amplían la funcionalidad de R al proporcionar funciones, datos y documentación adicionales.Están escritos por una comunidad mundial de usuarios de R y pueden ser instalados desde la interfaz gráfica de RStudio\nSolo tienes que instalar el paquete una vez, si desea actualizar un paquete previamente instalado a una versión más nueva, puede ir a la ventana de Ficheros en Packages > Update y seleccionar los paquetes que desea actualizar.\nNo podrá utilizar las funciones, los objetos y los archivos de ayuda de un paquete hasta que lo cargue con library(). Una vez que haya instalado un paquete, puede cargarlo con la función library():\n\n4.4.1 Diferencias entre paquetes y librerías\nEn el caso de la función library(), en muchas ocasiones existe la confusión entre un paquete y una librería, y podemos encontrarnos con gente llamando “librerías” a los paquetes.\nUna cosa es la función library() usada para cargar un paquete, y que se refiere al lugar en dónde el paquete es localizado, habitualmente una carpeta en nuestro ordenador, y otra un paquete que es una colección de funciones y datos empaquetados de forma conveniente.\nDicho de otra manera, y en palabras de Hadley Wickham, científico de datos en RStudio, y creador de la gran mayoría de paquetes del ecosistema tidyverse:\n\nDe igual manera, para recordar la diferencia es ejecutar la función library() sin argumentos. Esto nos proporcionará una lista de paquetes instalados en diferentes librerías en nuestro ordenador.\n\n\nCode\n# Install packages\ninstall.packages(\"tidyverse\")\n# Load packages\nlibrary(tidyverse)\n# You can also use \"pacman\" package to install\n#  an loading other packages\nif (!require(\"pacman\")) {\n  install.packages(\"pacman\")\n}\npacman::p_load(\n  tidyverse, formatR, knitr, rmdformats, pander, labelled, readxl, magrittr, kableExtra,\n  Lahman, datos\n)\n\n\nPara mayor información de R base, se recomienda la siguiente ."
  },
  {
    "objectID": "c04_tidyverse_1.html#dplyr-básico",
    "href": "c04_tidyverse_1.html#dplyr-básico",
    "title": "5  Manipulación de datos con tidyverse",
    "section": "5.1 Dplyr básico",
    "text": "5.1 Dplyr básico\nLa visualización es una herramienta importante para la generación de información, pero es raro obtener los datos exactamente como se necesitan. A menudo, necesitará crear algunas variables o resúmenes nuevos, o tal vez solo desee cambiar el nombre de las variables o reordenar las observaciones para que sea un poco más fácil trabajar con los datos. Para más detalles sobre cómo transformar sus datos es empleando el paquete dplyr\nPara explorar los verbos básicos de manipulación de datos de dplyr, usaremos la base de datos de zonas de amortiguamiento. Este marco de datos contiene. Los datos provienen de la Servicio Nacional de Áreas Naturales Protegidas (SERNANP)\n\n\nCode\n# datos será un 'data frame'\nz_amortiguamiento <- read_csv(file = 'data/zon_amortiguamiento.csv')\n\n\nNew names:\nRows: 80 Columns: 11\n── Column specification\n──────────────────────────────────────────────────────── Delimiter: \",\" chr\n(6): Codigo, Area_natur, Periodo, Base_legal, Base_leg00, Base_leg01 dbl (2):\n...1, Superficie date (3): Fecha_lega, Fecha_le00, Fecha_le01\nℹ Use `spec()` to retrieve the full column specification for this data. ℹ\nSpecify the column types or set `show_col_types = FALSE` to quiet this message.\n• `` -> `...1`\n\n\nCode\nhead(z_amortiguamiento)\n\n\n# A tibble: 6 × 11\n   ...1 Codigo Area_natur    Periodo Base_legal Fecha_lega Base_leg00 Fecha_le00\n  <dbl> <chr>  <chr>         <chr>   <chr>      <date>     <chr>      <date>    \n1     1 RC04   Ashaninka     2019-2… R.P. Nº 2… 2012-12-28 <NA>       1899-12-30\n2     2 BP03   de Pui Pui    2019-2… R.J. Nº 2… 2008-10-28 <NA>       1899-12-30\n3     3 RN12   Matsés        2023-2… R.P. Nº 0… 2014-02-27 <NA>       1899-12-30\n4     4 RN10   Allpahuayo M… 2022-2… R.J. Nº 1… 2007-07-24 <NA>       1899-12-30\n5     5 RN06   de Salinas y… 2016-2… R.J. Nº 0… 2007-04-26 <NA>       1899-12-30\n6     6 RN02   de Junín      2008-2… R.J. Nº 1… 2008-06-03 <NA>       1899-12-30\n# ℹ 3 more variables: Base_leg01 <chr>, Fecha_le01 <date>, Superficie <dbl>\n\n\nEn esta sección se muestran cinco funciones clave de dplyr que le permiten resolver la gran mayoría de sus desafíos de manipulación de datos:\n\nElija observaciones por sus valores (filter()).\nReordenar las filas (arrange()).\nElija las variables por sus nombres (select()).\nCrear nuevas variables con funciones de variables existentes (mutate()).\nColapsar muchos valores en un solo resumen (summarize())\n\nTodos estos se pueden usar junto con group_by(), que cambia el alcance de cada función de operar en todo el conjunto de datos a operar en él grupo por grupo. Estas seis funciones proporcionan los verbos para un lenguaje de manipulación de datos.\nTodos los verbos funcionan de manera similar:\n\nEl primer argumento es un data.frame(marco de datos).\nLos argumentos siguientes describen qué hacer con el marco de datos, utilizando los nombres de las variables (sin comillas).\nEl resultado es un nuevo dataframe.\n\nJuntas, estas propiedades hacen que sea fácil encadenar varios pasos simples para lograr un resultado complejo. Profundicemos y veamos cómo funcionan estos verbos.\n\n5.1.1 Filtrar filas con filter()\n\n\n\nFilter() te permite filtrar un subconjunto de observaciones según sus valores. El primer argumento es el nombre del data frame. El segundo y los siguientes argumentos son las expresiones que lo filtran.\nPor ejemplo, podemos seleccionar todas las ZA con una Superficie mayor a 400000.00 con:\n\n\nCode\ndplyr::filter(z_amortiguamiento, Superficie > 400000.00 )\n\n\n# A tibble: 7 × 11\n   ...1 Codigo Area_natur    Periodo Base_legal Fecha_lega Base_leg00 Fecha_le00\n  <dbl> <chr>  <chr>         <chr>   <chr>      <date>     <chr>      <date>    \n1    18 PN09   Cordillera A… 2017-2… R.P. Nº 0… 2011-04-14 <NA>       1899-12-30\n2    30 PN06   del Río Abis… 2014-2… R.J. Nº 2… 2006-09-27 <NA>       1899-12-30\n3    42 RN08   Pacaya-Samir… 2017-2… R.J. Nº 1… 2009-09-24 <NA>       1899-12-30\n4    51 RC02   El Sira       2015-2… R.P. Nº 0… 2009-02-27 <NA>       1899-12-30\n5    60 RP02   Subcuenca de… 2019-2… R.P. Nº 1… 2009-09-15 <NA>       1899-12-30\n6    66 PN11   Alto Purús    2019-2… R.P. Nº 2… 2012-12-28 <NA>       1899-12-30\n7    67 PN11   Alto Purús    2019-2… R.P. Nº 2… 2012-12-28 <NA>       1899-12-30\n# ℹ 3 more variables: Base_leg01 <chr>, Fecha_le01 <date>, Superficie <dbl>\n\n\nCuando ejecutas esa línea de código, dplyr ejecuta la operación de filtrado y devuelve un nuevo data frame. Las funciones de dplyr nunca modifican su input, por lo que si deseas guardar el resultado, necesitarás usar el operador de asignación, <-:\n\n\nCode\nfilter01 <- dplyr::filter(z_amortiguamiento,Superficie > 400000.00 )\n\n\nDe otro modo usar el operador “%>%” de la librería magrittr.\nR imprime los resultados o los guarda en una variable. Si desea hacer ambas cosas, puede envolver la tarea entre paréntesis:\n\n\nCode\n(filter02 <- dplyr::filter(z_amortiguamiento,Superficie > 400000.00))\n\n\n# A tibble: 7 × 11\n   ...1 Codigo Area_natur    Periodo Base_legal Fecha_lega Base_leg00 Fecha_le00\n  <dbl> <chr>  <chr>         <chr>   <chr>      <date>     <chr>      <date>    \n1    18 PN09   Cordillera A… 2017-2… R.P. Nº 0… 2011-04-14 <NA>       1899-12-30\n2    30 PN06   del Río Abis… 2014-2… R.J. Nº 2… 2006-09-27 <NA>       1899-12-30\n3    42 RN08   Pacaya-Samir… 2017-2… R.J. Nº 1… 2009-09-24 <NA>       1899-12-30\n4    51 RC02   El Sira       2015-2… R.P. Nº 0… 2009-02-27 <NA>       1899-12-30\n5    60 RP02   Subcuenca de… 2019-2… R.P. Nº 1… 2009-09-15 <NA>       1899-12-30\n6    66 PN11   Alto Purús    2019-2… R.P. Nº 2… 2012-12-28 <NA>       1899-12-30\n7    67 PN11   Alto Purús    2019-2… R.P. Nº 2… 2012-12-28 <NA>       1899-12-30\n# ℹ 3 more variables: Base_leg01 <chr>, Fecha_le01 <date>, Superficie <dbl>\n\n\n\n5.1.1.1 Comparaciones\nPara usar el filtrado de manera efectiva, debes saber cómo seleccionar las observaciones que deseas utilizando los operadores de comparación. R proporciona el conjunto estándar: >, >=, <, <=, != (no igual) y == (igual).\nCuando comienzas con R, el error más fácil de cometer es usar = en lugar de == cuando se busca igualdad. Cuando esto suceda, obtendrás un error informativo:\n\n\nCode\ndplyr::filter(z_amortiguamiento,Superficie > 400000.00)\n\n\n# A tibble: 7 × 11\n   ...1 Codigo Area_natur    Periodo Base_legal Fecha_lega Base_leg00 Fecha_le00\n  <dbl> <chr>  <chr>         <chr>   <chr>      <date>     <chr>      <date>    \n1    18 PN09   Cordillera A… 2017-2… R.P. Nº 0… 2011-04-14 <NA>       1899-12-30\n2    30 PN06   del Río Abis… 2014-2… R.J. Nº 2… 2006-09-27 <NA>       1899-12-30\n3    42 RN08   Pacaya-Samir… 2017-2… R.J. Nº 1… 2009-09-24 <NA>       1899-12-30\n4    51 RC02   El Sira       2015-2… R.P. Nº 0… 2009-02-27 <NA>       1899-12-30\n5    60 RP02   Subcuenca de… 2019-2… R.P. Nº 1… 2009-09-15 <NA>       1899-12-30\n6    66 PN11   Alto Purús    2019-2… R.P. Nº 2… 2012-12-28 <NA>       1899-12-30\n7    67 PN11   Alto Purús    2019-2… R.P. Nº 2… 2012-12-28 <NA>       1899-12-30\n# ℹ 3 more variables: Base_leg01 <chr>, Fecha_le01 <date>, Superficie <dbl>\n\n\nHay otro problema común que puedes encontrar al usar ==: los números de coma flotante. ¡Estos resultados pueden sorprenderte!\n\n\nCode\nsqrt(2)^2 == 2\n\n\n[1] FALSE\n\n\nCode\n1 / 49 * 49 == 1\n\n\n[1] FALSE\n\n\nLas computadoras usan aritmética de precisión finita (obviamente, NO pueden almacenar una cantidad infinita de dígitos), así que recuerda que cada número que observas es una aproximación. En lugar de confiar en ==, usa near() (cercano, en inglés):\n\n\nCode\nnear(sqrt(2)^2, 2)\n\n\n[1] TRUE\n\n\nCode\nnear(1 / 49 * 49, 1)\n\n\n[1] TRUE\n\n\n\n\n5.1.1.2 Operadores lógicos\nSi tienes múltiples argumentos para filter() estos se combinan con “y”: cada expresión debe ser verdadera para que una fila se incluya en el output. Para otros tipos de combinaciones necesitarás usar operadores Booleanos: & es “y”, | es “o”, y ! es “no”. La siguiente figura muestra el conjunto completo de operaciones Booleanas.\n\nEl siguiente código sirve para encontrar todas las areas iguales a 310242.10 o 1880.50:\n\n\nCode\ndplyr::filter(z_amortiguamiento, Superficie == 310242.10 | Superficie == 1880.50)\n\n\n# A tibble: 2 × 11\n   ...1 Codigo Area_natur    Periodo Base_legal Fecha_lega Base_leg00 Fecha_le00\n  <dbl> <chr>  <chr>         <chr>   <chr>      <date>     <chr>      <date>    \n1     5 RN06   de Salinas y… 2016-2… R.J. Nº 0… 2007-04-26 <NA>       1899-12-30\n2    52 SN03   Lagunas de M… 2015-2… R.P. Nº 2… 2015-10-29 <NA>       1899-12-30\n# ℹ 3 more variables: Base_leg01 <chr>, Fecha_le01 <date>, Superficie <dbl>\n\n\nEl orden de las operaciones es importante. No puedes escribir filter(z_amortiguamiento, Superficie == (310242.10 | 1880.50)). Si quieres saber si es uno u otro valor, se puede resolver con x %in% y (es decir, x en y). Esto seleccionará cada fila donde x es uno de los valores en y. Podríamos usarlo para reescribir el código de arriba:\n\n\nCode\ndplyr::filter(z_amortiguamiento, Superficie %in% c(310242.10, 1880.50))\n\n\n# A tibble: 2 × 11\n   ...1 Codigo Area_natur    Periodo Base_legal Fecha_lega Base_leg00 Fecha_le00\n  <dbl> <chr>  <chr>         <chr>   <chr>      <date>     <chr>      <date>    \n1     5 RN06   de Salinas y… 2016-2… R.J. Nº 0… 2007-04-26 <NA>       1899-12-30\n2    52 SN03   Lagunas de M… 2015-2… R.P. Nº 2… 2015-10-29 <NA>       1899-12-30\n# ℹ 3 more variables: Base_leg01 <chr>, Fecha_le01 <date>, Superficie <dbl>\n\n\nA veces puedes simplificar subconjuntos complicados al recordar la ley de De Morgan: !(x & y) es lo mismo que !x | !y, y !(x | y) es lo mismo que **!x & !y*. Por ejemplo, si deseas encontrar areas mayores a 26.2 y menores 8652.24 .\n\n\nCode\ndplyr::filter(z_amortiguamiento,!(Superficie > 8652.24  | Superficie < 26.2))\n\n\n# A tibble: 21 × 11\n    ...1 Codigo Area_natur   Periodo Base_legal Fecha_lega Base_leg00 Fecha_le00\n   <dbl> <chr>  <chr>        <chr>   <chr>      <date>     <chr>      <date>    \n 1     9 SH02   de la Pampa… 2016-2… R.P. N° 0… 2016-01-29 <NA>       1899-12-30\n 2    10 SH01   de Chacamar… 2002-2… R.J. Nº 4… 2002-12-20 <NA>       1899-12-30\n 3    13 SN04   de Ampay     2015-2… R.P. Nº 1… 2014-12-22 <NA>       1899-12-30\n 4    14 SN01   de Huayllay  2018-2… R.J. Nº 3… 2001-12-13 <NA>       1899-12-30\n 5    21 PN05   Cerros de A… 2012-2… R.P. N° 0… 2012-02-17 Ley N° 30… 2015-11-11\n 6    36 SN05   los Manglar… 2023-2… R.P. N° 0… 2017-02-28 <NA>       1899-12-30\n 7    37 RC05   Machiguenga  2023-2… R.P. N° 0… 2017-02-28 <NA>       1899-12-30\n 8    39 SN07   Pampa Hermo… 2022-2… R.P. Nº 2… 2012-12-28 <NA>       1899-12-30\n 9    40 RVS01  Laquipampa   2015-2… R.P. Nº 0… 2015-01-27 <NA>       1899-12-30\n10    41 RVS02  Los Pantano… 2016-2… R.J. Nº 3… 2001-12-28 <NA>       1899-12-30\n# ℹ 11 more rows\n# ℹ 3 more variables: Base_leg01 <chr>, Fecha_le01 <date>, Superficie <dbl>\n\n\n\n\n\n5.1.2 Reordenar las filas con arrange()\narrange()** funciona de manera similar afilter()` excepto que en lugar de seleccionar filas, cambia su orden. La función toma un dataframe** y un conjunto de nombres de columnas (o expresiones más complicadas) para ordenar según ellas. Si proporcionas más de un nombre de columna, cada columna adicional se utilizará para romper empates en los valores de las columnas anteriores:\n\n\nCode\narrange(z_amortiguamiento, Codigo)\n\n\n# A tibble: 80 × 11\n    ...1 Codigo Area_natur   Periodo Base_legal Fecha_lega Base_leg00 Fecha_le00\n   <dbl> <chr>  <chr>        <chr>   <chr>      <date>     <chr>      <date>    \n 1     2 BP03   de Pui Pui   2019-2… R.J. Nº 2… 2008-10-28 <NA>       1899-12-30\n 2    75 BP04   San Matias-… 2023-2… R.P. N° 2… 2015-11-27 <NA>       1899-12-30\n 3    53 BP05   de Pagaibam… 2017-2… R.J. Nº 3… 2001-12-13 <NA>       1899-12-30\n 4    77 BP06   Alto Mayo    2023-2… R.P. Nº 0… 2023-02-27 <NA>       1899-12-30\n 5    57 CC01   El Angolo    2019-2… R.P. N° 2… 2012-11-28 <NA>       1899-12-30\n 6    29 CC02   Sunchubamba  <NA>    R.J. Nº 3… 2001-12-13 <NA>       1899-12-30\n 7    26 PN01   de Cutervo   2017-2… R.P. Nº 1… 2009-09-24 <NA>       1899-12-30\n 8    56 PN02   de Tingo Ma… 2022-2… R.P. N° 0… 2017-03-31 <NA>       1899-12-30\n 9    24 PN03   del Manu     2019-2… R.P. Nº 0… 2013-05-22 <NA>       1899-12-30\n10    25 PN03   del Manu     2019-2… R.P. Nº 0… 2013-05-22 <NA>       1899-12-30\n# ℹ 70 more rows\n# ℹ 3 more variables: Base_leg01 <chr>, Fecha_le01 <date>, Superficie <dbl>\n\n\nUsa desc() para reordenar por una columna en orden descendente:\n\n\nCode\narrange(z_amortiguamiento, desc(Superficie))\n\n\n# A tibble: 80 × 11\n    ...1 Codigo Area_natur   Periodo Base_legal Fecha_lega Base_leg00 Fecha_le00\n   <dbl> <chr>  <chr>        <chr>   <chr>      <date>     <chr>      <date>    \n 1    18 PN09   Cordillera … 2017-2… R.P. Nº 0… 2011-04-14 <NA>       1899-12-30\n 2    42 RN08   Pacaya-Sami… 2017-2… R.J. Nº 1… 2009-09-24 <NA>       1899-12-30\n 3    51 RC02   El Sira      2015-2… R.P. Nº 0… 2009-02-27 <NA>       1899-12-30\n 4    67 PN11   Alto Purús   2019-2… R.P. Nº 2… 2012-12-28 <NA>       1899-12-30\n 5    30 PN06   del Río Abi… 2014-2… R.J. Nº 2… 2006-09-27 <NA>       1899-12-30\n 6    66 PN11   Alto Purús   2019-2… R.P. Nº 2… 2012-12-28 <NA>       1899-12-30\n 7    60 RP02   Subcuenca d… 2019-2… R.P. Nº 1… 2009-09-15 <NA>       1899-12-30\n 8    24 PN03   del Manu     2019-2… R.P. Nº 0… 2013-05-22 <NA>       1899-12-30\n 9    15 PN14   Sierra del … 2023-2… R.P. N° 2… 2016-11-07 <NA>       1899-12-30\n10    28 RN14   Pucacuro     2019-2… R.P. Nº 0… 2013-03-20 <NA>       1899-12-30\n# ℹ 70 more rows\n# ℹ 3 more variables: Base_leg01 <chr>, Fecha_le01 <date>, Superficie <dbl>\n\n\n\n\n5.1.3 Seleccionar columnas con select()\n\n\n\nNo es raro obtener conjuntos de datos con cientos de variables. En este caso, el primer desafío a menudo se reduce a las variables que realmente te interesan. select() te permite seleccionar rápidamente un subconjunto útil utilizando operaciones basadas en los nombres de las variables.\nEn este caso emplearemos select() para quedarnos con algunas columnas en específico:\n\n\nCode\n# Seleccionar columnas por nombre\ndplyr::select(z_amortiguamiento, Codigo, Area_natur)\n\n\n# A tibble: 80 × 2\n   Codigo Area_natur                      \n   <chr>  <chr>                           \n 1 RC04   Ashaninka                       \n 2 BP03   de Pui Pui                      \n 3 RN12   Matsés                          \n 4 RN10   Allpahuayo Mishana              \n 5 RN06   de Salinas y Aguada Blanca      \n 6 RN02   de Junín                        \n 7 RN01   Pampa Galeras Barbara D' Achille\n 8 SH04   Bosque de Pomac                 \n 9 SH02   de la Pampa de Ayacucho         \n10 SH01   de Chacamarca                   \n# ℹ 70 more rows\n\n\nCode\n# Seleccionar todas las columnas entre Codigo y Periodo (incluyente)\ndplyr::select(z_amortiguamiento, Codigo:Periodo)\n\n\n# A tibble: 80 × 3\n   Codigo Area_natur                       Periodo  \n   <chr>  <chr>                            <chr>    \n 1 RC04   Ashaninka                        2019-2023\n 2 BP03   de Pui Pui                       2019-2023\n 3 RN12   Matsés                           2023-2027\n 4 RN10   Allpahuayo Mishana               2022-2026\n 5 RN06   de Salinas y Aguada Blanca       2016-2020\n 6 RN02   de Junín                         2008-2012\n 7 RN01   Pampa Galeras Barbara D' Achille 2022-2026\n 8 SH04   Bosque de Pomac                  2017-2021\n 9 SH02   de la Pampa de Ayacucho          2016-2020\n10 SH01   de Chacamarca                    2002-2007\n# ℹ 70 more rows\n\n\nCode\n# Seleccionar todas las columnas excepto aquellas entre Codigo y Periodo (incluyente)\ndplyr::select(z_amortiguamiento, -(Codigo:Periodo))\n\n\n# A tibble: 80 × 8\n    ...1 Base_legal       Fecha_lega Base_leg00 Fecha_le00 Base_leg01 Fecha_le01\n   <dbl> <chr>            <date>     <chr>      <date>     <chr>      <date>    \n 1     1 R.P. Nº 239-201… 2012-12-28 <NA>       1899-12-30 R.P. N° 0… 2019-01-29\n 2     2 R.J. Nº 285-200… 2008-10-28 <NA>       1899-12-30 R.P. N° 0… 2019-01-29\n 3     3 R.P. Nº 054-201… 2014-02-27 <NA>       1899-12-30 R.P N° 32… 2022-12-29\n 4     4 R.J. Nº 159-200… 2007-07-24 <NA>       1899-12-30 R.P. N° 0… 2022-03-15\n 5     5 R.J. Nº 087-200… 2007-04-26 <NA>       1899-12-30 R.P. N° 2… 2016-09-14\n 6     6 R.J. Nº 145-200… 2008-06-03 <NA>       1899-12-30 <NA>       1899-12-30\n 7     7 R.J. Nº 331-200… 2001-12-13 <NA>       1899-12-30 R.P. N° 0… 2022-03-02\n 8     8 R.P. Nº 006-201… 2011-01-19 <NA>       1899-12-30 R.P. N° 9… 2017-03-31\n 9     9 R.P. N° 019-201… 2016-01-29 <NA>       1899-12-30 <NA>       1899-12-30\n10    10 R.J. Nº 466-200… 2002-12-20 <NA>       1899-12-30 <NA>       1899-12-30\n# ℹ 70 more rows\n# ℹ 1 more variable: Superficie <dbl>\n\n\nHay una serie de funciones auxiliares que puedes usar dentro de select():\n\nstarts_with(\"abc\"): coincide con los nombres que comienzan con “abc”.\nends_with(\"xyz\"): coincide con los nombres que terminan con “xyz”.\ncontains(\"ijk\"): coincide con los nombres que contienen “ijk”.\nmatches(\"(.)\\\\1\"): selecciona variables que coinciden con una expresión regular (regex). Esta en particular coincide con cualquier variable que contenga caracteres repetidos.\nnum_range(\"x\", 1:3): coincide con x1,x2 y x3.\n\nConsulta ?select para ver más detalles.\nselect() se puede usar para cambiar el nombre de las variables, pero rara vez es útil porque descarta todas las variables que no se mencionan explícitamente. En su lugar, utiliza rename(), que es una variante de select() que mantiene todas las variables que no se mencionan explícitamente:\n\n\nCode\nnames(z_amortiguamiento)\n\n\n [1] \"...1\"       \"Codigo\"     \"Area_natur\" \"Periodo\"    \"Base_legal\"\n [6] \"Fecha_lega\" \"Base_leg00\" \"Fecha_le00\" \"Base_leg01\" \"Fecha_le01\"\n[11] \"Superficie\"\n\n\nCode\n# new name = old name\ndf <- rename(z_amortiguamiento, \"Baselegal\" = Base_legal)\nnames(df)\n\n\n [1] \"...1\"       \"Codigo\"     \"Area_natur\" \"Periodo\"    \"Baselegal\" \n [6] \"Fecha_lega\" \"Base_leg00\" \"Fecha_le00\" \"Base_leg01\" \"Fecha_le01\"\n[11] \"Superficie\"\n\n\nOtra opción es usar select() junto con el auxiliar everything() (todo, en inglés). Esto es útil si tienes un grupo de variables que te gustaría mover al comienzo del data frame.\n\n\nCode\ndplyr::select(z_amortiguamiento, Superficie, everything())\n\n\n# A tibble: 80 × 11\n   Superficie  ...1 Codigo Area_natur   Periodo Base_legal Fecha_lega Base_leg00\n        <dbl> <dbl> <chr>  <chr>        <chr>   <chr>      <date>     <chr>     \n 1    325684.     1 RC04   Ashaninka    2019-2… R.P. Nº 2… 2012-12-28 <NA>      \n 2     45367.     2 BP03   de Pui Pui   2019-2… R.J. Nº 2… 2008-10-28 <NA>      \n 3    231398.     3 RN12   Matsés       2023-2… R.P. Nº 0… 2014-02-27 <NA>      \n 4     65957.     4 RN10   Allpahuayo … 2022-2… R.J. Nº 1… 2007-07-24 <NA>      \n 5    310242.     5 RN06   de Salinas … 2016-2… R.J. Nº 0… 2007-04-26 <NA>      \n 6    100858.     6 RN02   de Junín     2008-2… R.J. Nº 1… 2008-06-03 <NA>      \n 7     14531.     7 RN01   Pampa Galer… 2022-2… R.J. Nº 3… 2001-12-13 <NA>      \n 8      9291.     8 SH04   Bosque de P… 2017-2… R.P. Nº 0… 2011-01-19 <NA>      \n 9       429.     9 SH02   de la Pampa… 2016-2… R.P. N° 0… 2016-01-29 <NA>      \n10      1332.    10 SH01   de Chacamar… 2002-2… R.J. Nº 4… 2002-12-20 <NA>      \n# ℹ 70 more rows\n# ℹ 3 more variables: Fecha_le00 <date>, Base_leg01 <chr>, Fecha_le01 <date>\n\n\n\n\n5.1.4 Añadir nuevas variables con mutate()\n\n\n\nAdemás de seleccionar conjuntos de columnas existentes, a menudo es útil crear nuevas columnas en función de columnas existentes. Ese es el trabajo de mutate() (del inglés mutar o transformar).\nmutate() siempre agrega nuevas columnas al final de un conjunto de datos, así que comenzaremos creando un conjunto de datos más pequeño para que podamos ver las nuevas variables. Recuerda que cuando usas RStudio, la manera más fácil de ver todas las columnas es View().\n\n\nCode\nz_amortiguamiento_sl <- dplyr::select(\n  z_amortiguamiento,\n  Codigo:Periodo,\n  contains(\"leg\"),\n  Superficie\n)\n\nmutate(\n  z_amortiguamiento_sl,\n  area_ha = Superficie / 10000,\n  inicio_legal = str_split(Periodo, \"-\", simplify = TRUE)[,1],\n  fin_legal = str_split(Periodo, \"-\", simplify = TRUE)[,2]\n)\n\n\n# A tibble: 80 × 11\n   Codigo Area_natur         Periodo Base_legal Fecha_lega Base_leg00 Base_leg01\n   <chr>  <chr>              <chr>   <chr>      <date>     <chr>      <chr>     \n 1 RC04   Ashaninka          2019-2… R.P. Nº 2… 2012-12-28 <NA>       R.P. N° 0…\n 2 BP03   de Pui Pui         2019-2… R.J. Nº 2… 2008-10-28 <NA>       R.P. N° 0…\n 3 RN12   Matsés             2023-2… R.P. Nº 0… 2014-02-27 <NA>       R.P N° 32…\n 4 RN10   Allpahuayo Mishana 2022-2… R.J. Nº 1… 2007-07-24 <NA>       R.P. N° 0…\n 5 RN06   de Salinas y Agua… 2016-2… R.J. Nº 0… 2007-04-26 <NA>       R.P. N° 2…\n 6 RN02   de Junín           2008-2… R.J. Nº 1… 2008-06-03 <NA>       <NA>      \n 7 RN01   Pampa Galeras Bar… 2022-2… R.J. Nº 3… 2001-12-13 <NA>       R.P. N° 0…\n 8 SH04   Bosque de Pomac    2017-2… R.P. Nº 0… 2011-01-19 <NA>       R.P. N° 9…\n 9 SH02   de la Pampa de Ay… 2016-2… R.P. N° 0… 2016-01-29 <NA>       <NA>      \n10 SH01   de Chacamarca      2002-2… R.J. Nº 4… 2002-12-20 <NA>       <NA>      \n# ℹ 70 more rows\n# ℹ 4 more variables: Superficie <dbl>, area_ha <dbl>, inicio_legal <chr>,\n#   fin_legal <chr>\n\n\nSi solo quieres conservar las nuevas variables, usa transmute():\n\n\nCode\ntransmute(\n  z_amortiguamiento_sl,\n  area_ha = Superficie / 10000,\n  inicio_legal = str_split(Periodo, \"-\", simplify = TRUE)[,1],\n  fin_legal = str_split(Periodo, \"-\", simplify = TRUE)[,2]\n)\n\n\n# A tibble: 80 × 3\n   area_ha inicio_legal fin_legal\n     <dbl> <chr>        <chr>    \n 1 32.6    2019         2023     \n 2  4.54   2019         2023     \n 3 23.1    2023         2027     \n 4  6.60   2022         2026     \n 5 31.0    2016         2020     \n 6 10.1    2008         2012     \n 7  1.45   2022         2026     \n 8  0.929  2017         2021     \n 9  0.0429 2016         2020     \n10  0.133  2002         2007     \n# ℹ 70 more rows\n\n\n\n5.1.4.1 Funciones de creación útiles\nHay muchas funciones para crear nuevas variables que puedes usar con mutate(). La propiedad clave es que la función debe ser vectorizada: debe tomar un vector de valores como input, y devolver un vector con el mismo número de valores como output. No hay forma de enumerar todas las posibles funciones que podrías usar, pero aquí hay una selección de funciones que frecuentemente son útiles:\n\nOperadores aritméticos: +, -, *, /, ^. Todos están vectorizados usando las llamadas “reglas de reciclaje”. Si un parámetro es más corto que el otro, se extenderá automáticamente para tener la misma longitud. Esto es muy útil cuando uno de los argumentos es un solo número: Superficie / 100000, hours * 60 + minute, etc. Los operadores aritméticos también son útiles junto con las funciones de agregar que aprenderás más adelante. Por ejemplo, x / sum(x) calcula la proporción de un total, y y - mean(y) calcula la diferencia de la media.\nAritmética modular: %/% (división entera) y %% (resto), donde x == y * (x %/% y) + (x %% y). La aritmética modular es una herramienta útil porque te permite dividir enteros en partes.\nLogaritmos: log(), log2(), log10(). Los logaritmos son increíblemente útiles como transformación para trabajar con datos con múltiples órdenes de magnitud. También convierten las relaciones multiplicativas en aditivas, bastante empleados cuando se trabajan con modelos. En igualdad de condiciones, recomendamos usar log2() porque es más fácil de interpretar: una diferencia de 1 en la escala de registro corresponde a la duplicación de la escala original y una diferencia de -1 corresponde a dividir a la mitad.\nRezagos: lead() y lag() te permiten referirte a un valor adelante o un valor atrás (con rezago). Esto te permite calcular las diferencias móviles (por ejemplo, x - lag(x)) o encontrar cuándo cambian los valores (x! = lag (x)). Estos comandos son más útiles cuando se utilizan junto con group_by(), algo que aprenderás en breve.\n\n\n\nCode\n(x <- 1:10)\n\n\n [1]  1  2  3  4  5  6  7  8  9 10\n\n\nCode\nlag(x)\n\n\n [1] NA  1  2  3  4  5  6  7  8  9\n\n\nCode\nlead(x)\n\n\n [1]  2  3  4  5  6  7  8  9 10 NA\n\n\n\nAgregados acumulativos y móviles: R proporciona funciones para ejecutar sumas, productos, mínimos y máximos: cumsum(), cumprod(), cummin(), cummax(); dplyr, por su parte, proporciona cummean() para las medias acumuladas. Si necesitas calcular agregados móviles (es decir, una suma calculada en una ventana móvil), prueba el paquete RcppRoll.\n\n\n\nCode\nx\n\n\n [1]  1  2  3  4  5  6  7  8  9 10\n\n\nCode\ncumsum(x)\n\n\n [1]  1  3  6 10 15 21 28 36 45 55\n\n\nCode\ncummean(x)\n\n\n [1] 1.0 1.5 2.0 2.5 3.0 3.5 4.0 4.5 5.0 5.5\n\n\n\nComparaciones lógicas: <, <=, >, >=, !=. Si estás haciendo una secuencia compleja de operaciones lógicas, es a menudo una buena idea almacenar los valores provisionales en nuevas variables para que puedas comprobar que cada paso funciona como se espera.\n\n\n\n\n5.1.5 Resúmenes agrupados con summarise()\nEl último verbo clave es summarise() (resumir, en inglés). Se encarga de colapsar un data frame en una sola fila:\n\n\nCode\nsummarize(z_amortiguamiento, area_mean = mean(Superficie, na.rm = TRUE))\n\n\n# A tibble: 1 × 1\n  area_mean\n      <dbl>\n1   181865.\n\n\nEn caso se requiera categorizar una columna utilizaremos case_when() dentro de la función mutate().\nsummarise() no es muy útil a menos que lo enlacemos con group_by(). Esto cambia la unidad de análisis del conjunto de datos completo a grupos individuales. Luego, cuando uses los verbos dplyr en un data frame agrupado, estos se aplicarán automáticamente “por grupo”. Por ejemplo, si aplicamos exactamente el mismo código a un dataframe agrupado por fecha, obtenemos el retraso promedio por fecha:\n\n\nCode\nz_amortiguamiento_g <- mutate(z_amortiguamiento, \n       Grupo = case_when(\n         Superficie < 50000 ~ \"Grupo1\",\n         Superficie >= 50000 & Superficie <= 100000 ~ \"Grupo2\",\n         Superficie >= 100000 & Superficie <= 200000 ~ \"Grupo3\",\n         Superficie >= 200000 ~ \"Grupo4\"\n       ))\nby_group <- group_by(z_amortiguamiento_g, Grupo)\nsummarize(by_group, sup_mean = mean(Superficie, na.rm = TRUE))\n\n\n# A tibble: 4 × 2\n  Grupo  sup_mean\n  <chr>     <dbl>\n1 Grupo1   12494.\n2 Grupo2   68255.\n3 Grupo3  144261.\n4 Grupo4  513469.\n\n\nJuntos group_by() y summarise() proporcionan una de las herramientas que más comúnmente usarás cuando trabajes con dplyr: resúmenes agrupados. Pero antes de ir más allá con esto, tenemos que introducir una idea nueva y poderosa: el pipe (pronunciado /paip/, que en inglés significa ducto o tubería)."
  },
  {
    "objectID": "c04_tidyverse_1.html#combinación-de-múltiples-operaciones-con-el-pipe",
    "href": "c04_tidyverse_1.html#combinación-de-múltiples-operaciones-con-el-pipe",
    "title": "5  Manipulación de datos con tidyverse",
    "section": "5.2 Combinación de múltiples operaciones con el pipe",
    "text": "5.2 Combinación de múltiples operaciones con el pipe\nImagina que queremos agrupar por grupos y generar un resumen de cuántos elementos y la media de estos hay en cada uno de ellos.\nla relación entre la distancia y el atraso promedio para cada ubicación. Usando lo que sabes acerca de dplyr, podrías escribir un código como este:\n\n\nCode\nz_amortiguamiento_r <- z_amortiguamiento_g %>% \n  group_by(Grupo) %>% \n  summarise(\n    cantidad = n(),\n    sup_mean = mean(Superficie, na.rm = TRUE)\n  )\n\nggplot(data = z_amortiguamiento_r, mapping = aes(x = Grupo, y = cantidad)) +\n geom_col(aes(size = cantidad), alpha = 1/3) +\n geom_smooth(se = FALSE)\n\n\n`geom_smooth()` using method = 'loess' and formula = 'y ~ x'\n\n\n\n\n\nSe puede resumir en tres pasos para preparar la información:\n\nAgrupar los datos según el criterio a analizar.\nResumir para calcular la cantidad de cada grupo y el promedio por cada uno de ellos.\nFiltrar para eliminar datos ruidosos.\n\nLo que permite el uso del pipe es hacer una secuencia más fácil de leer. Se puede leer como una serie de declaraciones imperativas: agrupa, luego resume y luego filtra. Como sugiere esta lectura, una buena forma de pronunciar %>% cuando se lee el código es “luego”.\nLo que ocurre detrás del código, es que x %>% f(y) se convierte en f(x, y), y x %>% f(y) %>% g(z) se convierte en g(f(x, y), z) y así sucesivamente. Puedes usar el pipe para reescribir múltiples operaciones de forma que puedas leer de izquierda a derecha, de arriba hacia abajo. Usaremos pipes con frecuencia a partir de ahora porque mejora considerablemente la legibilidad del código.\nTrabajar con el pipe es uno de los criterios clave para pertenecer al tidyverse. La única excepción es ggplot2: se escribió antes de que se descubriera el pipe. Lamentablemente, la siguiente iteración de ggplot2, ggvis, que sí utiliza el pipe, aún no está lista para el horario estelar."
  },
  {
    "objectID": "c04_tidyverse_3.html#plot-con-r-base",
    "href": "c04_tidyverse_3.html#plot-con-r-base",
    "title": "6  Gráficos en R",
    "section": "6.1 Plot con R base",
    "text": "6.1 Plot con R base\nAquí haremos algunos ejemplos sobre cómo realizar gráficos sencillos con plot() a partir de un dataframe especificando los argumentos x e y.\n\n\nCode\ndata = data.frame(\n  x=seq(1:100) + 0.1*seq(1:100)*sample(c(1:10) , 100 , replace=T),\n  y=seq(1:100) + 0.2*seq(1:100)*sample(c(1:10) , 100 , replace=T)\n)\nplot(x=data$x, y=data$y)\n\n\n\n\n\nAquí mostramos una breve descripción de la personalización más común: - cex: Tamaño de puntos - xlim y ylim: Límites de los ejes X e Y - pch: Forma de los marcadores. Ver todos aquí. - xlab y ylab: Etiquetas de los ejes X e Y - col: Color del marcador - main: Título del gráfico\n\n\nCode\nplot(data$x, data$y,\n     xlim=c(0,250) , ylim=c(0,250), \n     pch=18, \n     cex=2, \n     col=\"#69b3a2\",\n     xlab=\"Valor de X\", ylab=\"Valor de Y\",\n     main=\"Un scatterplot simple\"\n     )\n\n\n\n\n\n\n\nCode\n# Boxplot\nboxplot(data$x, data$y,\n     col=\"#69b3a2\",\n     xlab=\"Valor de X\", ylab=\"Valor de Y\",\n     main=\"Un scatterplot simple\"\n     )\nlegend(\"topleft\", pch=\"*\", col=c(\"blue\", \"green\"), c(\"A\", \"B\"), cex=0.8,\n    title=\"Leyenda\")"
  },
  {
    "objectID": "c04_tidyverse_3.html#ahora-sí-ggplot2",
    "href": "c04_tidyverse_3.html#ahora-sí-ggplot2",
    "title": "6  Gráficos en R",
    "section": "6.2 Ahora sí! Ggplot2",
    "text": "6.2 Ahora sí! Ggplot2\nEsta sección se centra en ggplot2, uno de los paquetes principales de Tidyverse. Lo primero que haremos será comprobar si tenemos instalado tidyverse y si no lo tenemos, primero deberás instalarlo y luego ejecutar library():\n\n\nCode\ninstall.packages(\"tidyverse\")\nlibrary(tidyverse)\n\n\nSolo es necesario que instales los paquetes una única vez; sin embargo, tendrás que cargarlos siempre que inicies una nueva sesión.\nCuando necesitemos especificar la procedencia de una función (o un conjunto de datos), usaremos el formato especial paquete::funcion(). Por ejemplo, ggplot2::ggplot() dice explícitamente que estamos usando la función ggplot() del paquete ggplot2.\nAdemás del Tidyverse, es necesario que cargues el paquete datos, ya que en él están contenidas las versiones en español de los datos que utilizaremos en este capítulo:\n\n\nCode\n# install.packages(\"datos\")\nlibrary(tidyverse)\nlibrary(datos)\n\n\n\n6.2.1 Primeros pasos\nEn este primer ejercicio usaremos la base de datos millas. Simplemente analizando los datos intentaremos responder a las preguntas: ¿los automóviles con motores grandes consumen más combustible que los automóviles con motores pequeños? ¿Cómo es la relación entre el tamaño del motor y la eficiencia del combustible? ¿Es positiva? ¿Es negativa? ¿Es lineal o no lineal?\n\n\n6.2.2 El data frame millas\nEsta data la podemos cargar con la librería datos, (datos::millas). El data frame millas contiene observaciones para 38 modelos de automóviles recopiladas por la Agencia de Protección Ambiental de los EE. UU.\n\n\nCode\nmillas\n\n\n# A tibble: 234 × 11\n   fabricante modelo     cilindrada  anio cilindros transmision traccion ciudad\n   <chr>      <chr>           <dbl> <int>     <int> <chr>       <chr>     <int>\n 1 audi       a4                1.8  1999         4 auto(l5)    d            18\n 2 audi       a4                1.8  1999         4 manual(m5)  d            21\n 3 audi       a4                2    2008         4 manual(m6)  d            20\n 4 audi       a4                2    2008         4 auto(av)    d            21\n 5 audi       a4                2.8  1999         6 auto(l5)    d            16\n 6 audi       a4                2.8  1999         6 manual(m5)  d            18\n 7 audi       a4                3.1  2008         6 auto(av)    d            18\n 8 audi       a4 quattro        1.8  1999         4 manual(m5)  4            18\n 9 audi       a4 quattro        1.8  1999         4 auto(l5)    4            16\n10 audi       a4 quattro        2    2008         4 manual(m6)  4            20\n# ℹ 224 more rows\n# ℹ 3 more variables: autopista <int>, combustible <chr>, clase <chr>\n\n\nEntre las variables de millas se encuentran:\n\ncilindrada: tamaño del motor del automóvil, en litros.\nautopista: eficiencia del uso de combustible de un automóvil en carretera, en millas por galón. Al recorrer la misma distancia, un automóvil de baja eficiencia consume más combustible que un automóvil de alta eficiencia.\n\nPara obtener más información sobre el data frame millas, abre su página de ayuda ejecutando ?millas.\n\n\n6.2.3 Creando un gráfico con ggplot\nPara graficar millas, ejecuta este código para poner cilindrada en el eje x y autopista en el eje y:\n\n\nCode\nggplot(data = millas) +\n  geom_point(mapping = aes(x = cilindrada, y = autopista))\n\n\n\n\n\nEl gráfico muestra una relación negativa entre el tamaño del motor (cilindrada) y la eficiencia del combustible (autopista). En otras palabras, los vehículos con motores grandes usan más combustible. Este resultado, ¿confirma o refuta tu hipótesis acerca de la relación entre la eficiencia del combustible y el tamaño del motor?\nPara comenzar un gráfico con ggplot2 se utiliza la función ggplot(). ggplot() crea un sistema de coordenadas al que puedes agregar capas. El primer argumento de ggplot() es el conjunto de datos que se utilizará en el gráfico. Si corres ggplot(data = millas), obtendrás un gráfico vacío. Como no es muy interesante, no vamos a mostrarlo aquí.\nPara completar tu gráfico debes agregar una o más capas a ggplot(). La función geom_point() agrega una capa de puntos al gráfico, lo que crea un diagrama de dispersión (o scatterplot). ggplot2 incluye muchas funciones geom, cada una de las cuales agrega un tipo de capa diferente a un gráfico. Aprenderás muchas de ellas a lo largo de este capítulo.\nCada función geom en ggplot2 tiene un argumento de mapping. Este define cómo se “mapean” o se asignan las variables del conjunto de datos a propiedades visuales. El argumento de mapping siempre aparece emparejado con aes() y los argumentos x e y dentro de aes() especifican qué variables asignar a estos ejes. ggplot2 busca la variable asignada en el argumento data, en este caso, millas.\n\n\n6.2.4 Una plantilla de gráficos\nConvirtamos ahora este código en una plantilla reutilizable para hacer gráficos con ggplot2. Para hacer un gráfico, reemplaza las secciones entre corchetes en el siguiente código con un conjunto de datos, una función geom o una colección de mapeos.\n\n\nCode\nggplot(data = <DATOS>) +\n  <GEOM_FUNCIÓN>(mapping = aes(<MAPEOS>))\n\n\nEl resto de este capítulo te mostrará cómo utilizar y adaptar esta plantilla para crear diferentes tipos de gráficos. Comenzaremos por el componente <MAPEOS>\nEjercicios\n- Ejecuta ggplot(data = millas). ¿Qué observas?\n- ¿Cuántas filas hay en millas? ¿Cuántas columnas?\n- ¿Qué describe la variable traccion? Lee la ayuda de ?millas para encontrar la respuesta.\n- Realiza un gráfico de dispersión de autopista versus cilindros.\n- ¿Qué sucede cuando haces un gráfico de dispersión (scatterplot) de clase versus traccion? ¿Por qué no es útil este gráfico?"
  },
  {
    "objectID": "c04_tidyverse_3.html#mapeos-estéticos",
    "href": "c04_tidyverse_3.html#mapeos-estéticos",
    "title": "6  Gráficos en R",
    "section": "6.3 Mapeos estéticos",
    "text": "6.3 Mapeos estéticos\n“El mayor valor de una imagen es cuando nos obliga a observar lo que no esperábamos ver”. — John Tukey\nEn el siguiente gráfico, un grupo de puntos (resaltados en rojo) parece quedar fuera de la tendencia lineal. Estos automóviles tienen un kilometraje mayor de lo que esperaríamos. ¿Cómo puedes explicar estos vehículos?\n\n\n\nSupongamos que estos automóviles son híbridos. Una forma de probar esta hipótesis es observando la variable que indica la clase de cada automóvil. La variable clase del conjunto de datos de millas clasifica los autos en grupos como compacto, mediano y SUV. Si los puntos periféricos corresponden a automóviles híbridos, deberían estar clasificados como compactos o, tal vez, subcompactos (ten en cuenta que estos datos se recopilaron antes de que las camionetas híbridas y SUV se hicieran populares).\nPuedes agregar una tercera variable, como clase, a un diagrama de dispersión bidimensional asignándolo a un parámetro estético. Un parámetro estético (o estética) es una propiedad visual de los objetos de un gráfico. Las estéticas incluye cosas como el tamaño, la forma o el color de tus puntos. Puedes mostrar un punto (como el siguiente) de diferentes maneras si cambias los valores de sus propiedades estéticas. Como ya usamos la palabra “valor” para describir los datos, usemos la palabra “nivel” para describir las propiedades estéticas. Aquí cambiamos los niveles del tamaño, la forma y el color de un punto para que el punto sea pequeño, triangular o azul:\n\n\n\nEl mapeo entre las propiedades estéticas de tu gráfico y las variables de tu dataset te permite comunicar información sobre tus datos. Por ejemplo, puedes asignar los colores de los puntos de acuerdo a la variable clase para indicar a qué clase pertenece cada automóvil.\n\n\nCode\nggplot(data = millas) +\n  geom_point(mapping = aes(x = cilindrada, y = autopista, color = clase))\n\n\n\n\n\n(Si prefieres el inglés británico, como Hadley, puedes usar colour en lugar de color).\nPara mapear (o asignar) una estética a una variable, debes asociar el nombre de la estética al de la variable dentro de aes(). ggplot2 asignará automáticamente un nivel único de la estética (en este ejemplo, un color) a cada valor único de la variable. Este proceso es conocido como escalamiento (scaling). ggplot2 acompañará el gráfico con una leyenda que explica qué niveles corresponden a qué valores.\nLos colores revelan que muchos de los puntos inusuales son automóviles de dos asientos. ¡Estos no parecen híbridos y son, de hecho, automóviles deportivos! Los automóviles deportivos tienen motores grandes, como las camionetas todo terreno o pickups, pero su cuerpo es pequeño, como los automóviles medianos y compactos, lo que mejora su consumo de gasolina. En retrospectiva, es poco probable que estos automóviles sean híbridos, ya que tienen motores grandes.\nEn el ejemplo anterior asignamos la variable clase a la estética de color, pero podríamos haberla asignado a la estética del tamaño del mismo modo. En este caso, el tamaño exacto de cada punto revelaría a qué clase pertenece. Recibimos aquí una advertencia (warning), porque mapear una variable no ordenada (clase) a una estética ordenada (size) no es una buena idea.\n\n\nCode\nggplot(data = millas) +\n  geom_point(mapping = aes(x = cilindrada, y = autopista, size = clase))\n\n\nWarning: Using size for a discrete variable is not advised.\n\n\n\n\n\nTambién podríamos haber asignado la variable clase a la estética alpha, que controla la transparencia de los puntos, o a la estética shape que controla la forma (shape) de los puntos.\n\n\nCode\nggplot(data = millas) +\n  geom_point(mapping = aes(x = cilindrada, y = autopista, alpha = clase))\n\n\nWarning: Using alpha for a discrete variable is not advised.\n\n\n\n\n\nCode\nggplot(data = millas) +\n  geom_point(mapping = aes(x = cilindrada, y = autopista, shape = clase))\n\n\nWarning: The shape palette can deal with a maximum of 6 discrete values because\nmore than 6 becomes difficult to discriminate; you have 7. Consider\nspecifying shapes manually if you must have them.\n\n\nWarning: Removed 62 rows containing missing values (`geom_point()`).\n\n\n\n\n\n¿Qué pasó con los SUV? ggplot2 solo puede usar seis formas a la vez. De forma predeterminada, los grupos adicionales no se grafican cuando se emplea la estética de la forma (shape).\nPara cada estética utilizamos aes() para asociar su nombre con la variable seleccionada para graficar. La función aes() reúne cada una de las asignaciones estéticas utilizadas por una capa y las pasa al argumento de mapeo de la capa. La sintaxis resalta una visión útil sobre x e y: las ubicaciones de x e y de un punto son en sí mismas también estéticas, es decir propiedades visuales que se puede asignar a las variables para mostrar información sobre los datos.\nUna vez que asignas (o “mapeas”) una estética, ggplot2 se ocupa del resto. El paquete selecciona una escala razonable para usar con la estética elegida y construye una leyenda que explica la relación entre niveles y valores. Para la estética x e y, ggplot2 no crea una leyenda, pero sí una línea que delimita el eje con sus marcas de graduación y una etiqueta. La línea del eje actúa como una leyenda; explica el mapeo entre ubicaciones y valores.\nTambién puedes fijar las propiedades estéticas de tu geom manualmente. Por ejemplo, podemos hacer que todos los puntos del gráfico sean azules:\n\n\nCode\nggplot(data = millas) +\n geom_point(mapping = aes(x = cilindrada, y = autopista), color = \"blue\")\n\n\n\n\n\nAquí, el color no transmite información sobre una variable, sino que cambia la apariencia del gráfico. Para establecer una estética de forma manual, debes usar el nombre de la estética como un argumento de la función geom; es decir, va fuera de aes(). Tendrás que elegir un nivel que tenga sentido para esa estética:\n\nEl nombre de un color como cadena de caracteres.\nEl tamaño de un punto en mm.\nLa forma de un punto como un número, tal como se muestra.\n\n\n\n\nR tiene 25 formas predefinidas que están identificadas por números. Hay algunas que parecen duplicados: por ejemplo 0, 15 y 22 son todos cuadrados. La diferencia viene de la interacción entre las estéticas color y fill (relleno). Las formas vacías (0–14) tienen un borde determinado por color; las formas sólidas (15–18) están rellenas con color; las formas rellenas (21–24) tienen un borde de color y están rellenas por fill.\nEjercicios\n- ¿Qué no va bien en este código? ¿Por qué hay puntos que no son azules?\n\n\nCode\n ggplot(data = millas) +\n   geom_point(mapping = aes(x = cilindrada, y = autopista, color = \"blue\"))\n\n\n\n\n\n- ¿Qué variables en millas son categóricas? ¿Qué variables son continuas? (Pista: escribe ?millas para leer la documentación de ayuda para este conjunto de datos). ¿Cómo puedes ver esta información cuando ejecutas millas?\n- Asigna una variable continua a color, size, y shape. ¿Cómo se comportan estas estéticas de manera diferente para variables categóricas y variables continuas?\n- ¿Qué ocurre si asignas o mapeas la misma variable a múltiples estéticas?\n- ¿Qué hace la estética stroke? ¿Con qué formas trabaja? (Pista: consulta ?geom_point)\n- ¿Qué ocurre si se asigna o mapea una estética a algo diferente del nombre de una variable, como aes(color = cilindrada < 5)?\n\n6.3.1 Problemas comunes\nA medida que empieces a escribir código en R, lo más probable es que te encuentres con problemas. No te preocupes, es lo más común. Hemos estado escribiendo código en R durante años, ¡y todos los días seguimos escribiendo código que no funciona!\nComienza comparando cuidadosamente el código que estás ejecutando con el código en este libro. R es extremadamente exigente y un carácter fuera de lugar puede marcar la diferencia. Asegúrate de que cada ( coincida con un ) y cada ” esté emparejado con otro”. Algunas veces ejecutarás el código y no pasará nada. Comprueba la parte izquierda de tu consola: si es un +, significa que R no cree que hayas escrito una expresión completa y está esperando que la termines. En este caso, normalmente es más fácil comenzar de nuevo desde cero presionando ESCAPE (la tecla esc) para cancelar el procesamiento del comando actual.\nUn problema común al crear gráficos con ggplot2 es colocar el + en el lugar equivocado: debe ubicarse al final de la línea, no al inicio. En otras palabras, asegúrate de no haber escrito accidentalmente un código como este:\n\n\nCode\nggplot(data = millas)\n+ geom_point(mapping = aes(x = cilindrada, y = autopista))\n\n\nSi esto no resuelve el problema, prueba con la ayuda. Puedes obtener ayuda sobre cualquier función de R ejecutando ?nombre_de_la_funcion en la consola o seleccionando el nombre de la función y presionando F1 en RStudio. No te preocupes si la ayuda no te parece tan útil, trata entonces de saltar a los ejemplos y buscar un pedazo de código que coincida con lo que intentas hacer.\nSi eso no ayuda, lee cuidadosamente el mensaje de error. ¡A veces la respuesta estará oculta allí! Sin embargo, cuando recién comienzas en R, puede que la respuesta esté en el mensaje de error, pero aún no sabes cómo entenderlo. Otra gran herramienta es Google: intenta buscar allí el mensaje de error, ya que es probable que otra persona haya tenido el mismo problema y haya obtenido ayuda en línea."
  },
  {
    "objectID": "c04_tidyverse_3.html#separar-en-facetas",
    "href": "c04_tidyverse_3.html#separar-en-facetas",
    "title": "6  Gráficos en R",
    "section": "6.4 Separar en facetas",
    "text": "6.4 Separar en facetas\nUna forma de agregar variables adicionales es con las estéticas. Otra forma particularmente útil para las variables categóricas consiste en dividir el gráfico en facetas, es decir, sub-gráficos que muestran cada uno un subconjunto de los datos.\nPara separar en facetas un gráfico según una sola variable, utiliza facet_wrap() (del inglés envolver una faceta). El primer argumento de facet_wrap() debería ser una fórmula creada con ~ seguida del nombre de una de las variable (aquí “fórmula” es el nombre de un tipo de estructura en R, no un sinónimo de “ecuación”). La variable que uses en facet_wrap() debe ser categórica.\n\n\nCode\nggplot(data = millas) +\n  geom_point(mapping = aes(x = cilindrada, y = autopista)) +\n  facet_wrap(~ clase, nrow = 2)\n\n\n\n\n\nPara separar en facetas un gráfico según las combinaciones de dos variables, agrega facet_grid() a tu código del gráfico (grid quiere decir cuadrícula en inglés). El primer argumento de facet_grid() también corresponde a una fórmula. Esta vez, la fórmula debe contener dos nombres de variables separados por un ~.\n\n\nCode\nggplot(data = millas) +\n  geom_point(mapping = aes(x = cilindrada, y = autopista)) +\n  facet_grid(traccion ~ cilindros)\n\n\n\n\n\nSi prefieres no separar en facetas las filas o columnas, remplaza por un . el nombre de alguna de las variables, por ejemplo + facet_grid(. ~ cilindros).\nEjercicios\n- ¿Qué ocurre si intentas separar en facetas una variable continua?\n- ¿Qué significan las celdas vacías que aparecen en el gráfico generado usando facet_grid(traccion ~ cilindros)? ¿Cómo se relacionan con este gráfico?\n\n\nCode\nggplot(data = millas) +\n  geom_point(mapping = aes(x = traccion, y = cilindros))\n\n\n- ¿Qué grafica el siguiente código? ¿Qué hace . ?\n\n\nCode\nggplot(data = millas) +\n  geom_point(mapping = aes(x = cilindrada, y = autopista)) +\n  facet_grid(traccion ~ .)\nggplot(data = millas) +\n  geom_point(mapping = aes(x = cilindrada, y = autopista)) +\n  facet_grid(. ~ cilindros)\n\n\n- Mira de nuevo el primer gráfico en facetas presentado en esta sección:\n\n\nCode\nggplot(data = millas) +\n  geom_point(mapping = aes(x = cilindrada, y = autopista)) +\n  facet_wrap(~ clase, nrow = 2)\n\n\n¿Cuáles son las ventajas de separar en facetas en lugar de aplicar una estética de color? ¿Cuáles son las desventajas? ¿Cómo cambiaría este balance si tuvieras un conjunto de datos más grande?\n- Lee ?facet_wrap. ¿Qué hace nrow? ¿Qué hace ncol? ¿Qué otras opciones controlan el diseño de los paneles individuales? ¿Por qué facet_grid() no tiene argumentos nrow y ncol?\n- Cuando usas facet_grid(), generalmente deberías poner la variable con un mayor número de niveles únicos en las columnas. ¿Por qué?"
  },
  {
    "objectID": "c04_tidyverse_3.html#objetos-geométricos",
    "href": "c04_tidyverse_3.html#objetos-geométricos",
    "title": "6  Gráficos en R",
    "section": "6.5 Objetos geométricos",
    "text": "6.5 Objetos geométricos\n¿En qué sentido estos dos gráficos son similares?\n\n \n\nAmbos gráficos contienen las mismas variables x e y, y ambos describen los mismos datos. Pero los gráficos no son idénticos. Cada uno utiliza un objeto visual diferente para representar los datos. En la sintaxis de ggplot2, decimos que usan diferentes geoms.\nUn geom es el objeto geométrico usado para representar datos de forma gráfica. La gente a menudo llama a los gráficos por el tipo de geom que utiliza. Por ejemplo, los diagramas de barras usan geoms de barra (bar), los diagramas de líneas usan geoms de línea (line), los diagramas de caja usan geoms de diagrama de caja (boxplot), y así sucesivamente. En inglés, los diagramas de puntos (llamados scatterplots) rompen la tendencia; ellos usan geom de punto (o point). Como vemos arriba, puedes usar diferentes geoms para graficar los mismos datos. La gráfica de arriba usa el geom de punto (geom_point()), y la gráfica de abajo usa el geom suavizado (geom_smooth()), una línea suavizada ajustada a los datos.\nPara cambiar el geom de tu gráfico, modifica la función geom que acompaña a ggplot(). Por ejemplo, para hacer los gráficos que se muestran arriba, puedes usar este código:\n\n\nCode\n# arriba\nggplot(data = millas) +\n  geom_point(mapping = aes(x = cilindrada, y = autopista))\n# abajo\nggplot(data = millas) +\n  geom_smooth(mapping = aes(x = cilindrada, y = autopista))\n\n\nCada función geom en ggplot2 toma un argumento de mapping. Sin embargo, no todas las estéticas funcionan con todos los geom. Puedes establecer la forma para un punto, pero no puedes establecer la “forma” de una línea. Por otro lado, para una línea podrías elegir el tipo de línea (linetype). geom_smooth() dibujará una línea diferente, con un tipo de línea distinto (linetype), para cada valor único de la variable que asignes al tipo de línea (linetype).\n\n\nCode\nggplot(data = millas) +\n  geom_smooth(mapping = aes(x = cilindrada, y = autopista, linetype = traccion))\n\n\n`geom_smooth()` using method = 'loess' and formula = 'y ~ x'\n\n\n\n\n\nAquí geom_smooth() separa los automóviles en tres líneas en función de su valor de traccion, que describe el tipo de transmisión de un automóvil. Una línea describe todos los puntos con un valor de 4, otra línea los de valor d, y una tercera línea describe los puntos con un valor t. Aquí, 4 significa tracción en las cuatro ruedas, d tracción delantera y t tracción trasera.\nSi esto suena extraño, podemos hacerlo más claro al superponer las líneas sobre los datos brutos y luego colorear todo según traccion.\n\n\n\n¡Observa que generamos un gráfico que contiene dos geoms! Si esto te emociona, abróchate el cinturón. En la siguiente sección aprenderemos cómo colocar múltiples geoms en el mismo gráfico.\nggplot2 proporciona más de 40 geoms y los paquetes de extensión proporcionan aún más (consulta https://exts.ggplot2.tidyverse.org/gallery/ para obtener una muestra). La mejor forma de obtener un panorama completo sobre las posibilidades que brinda ggplot2 es consultando la hoja de referencia (o cheatsheet), que puedes encontrar en https://rstudio.com/resources/cheatsheets/ (en la parte baja de la página encontrarás la versión en español). Para obtener más información sobre un tipo dado de geoms, usa la ayuda: ?geom_smooth.\nMuchos geoms, como geom_smooth(), usan un único objeto geométrico para mostrar múltiples filas de datos. Con estos geoms, puedes asignar la estética de group (grupo) a una variable categórica para graficar múltiples objetos. ggplot2 representará un objeto distinto por cada valor único de la variable de agrupamiento. En la práctica, ggplot2 agrupará automáticamente los datos para estos geoms siempre que se asigne una estética a una variable discreta (como en el ejemplo del tipo de línea o linetype). Es conveniente confiar en esta característica porque la estética del grupo en sí misma no agrega una leyenda o características distintivas a los geoms.\n\n\nCode\nggplot(data = millas) +\n  geom_smooth(mapping = aes(x = cilindrada, y = autopista))\n\n\n`geom_smooth()` using method = 'loess' and formula = 'y ~ x'\n\n\n\n\n\nCode\nggplot(data = millas) +\n  geom_smooth(mapping = aes(x = cilindrada, y = autopista, group = traccion))\n\n\n`geom_smooth()` using method = 'loess' and formula = 'y ~ x'\n\n\n\n\n\nCode\nggplot(data = millas) +\n  geom_smooth(\n    mapping = aes(x = cilindrada, y = autopista, color = traccion),\n    show.legend = FALSE\n  )\n\n\n`geom_smooth()` using method = 'loess' and formula = 'y ~ x'\n\n\n\n\n\nPara mostrar múltiples geoms en el mismo gráfico, agrega varias funciones geom a ggplot():\n\n\nCode\nggplot(data = millas) +\n  geom_point(mapping = aes(x = cilindrada, y = autopista)) +\n  geom_smooth(mapping = aes(x = cilindrada, y = autopista))\n\n\n`geom_smooth()` using method = 'loess' and formula = 'y ~ x'\n\n\n\n\n\nEsto introduce, sin embargo, cierta duplicación en nuestro código. Imagina que deseas cambiar el eje y para mostrar cilindrada en lugar de autopista. Necesitarías cambiar la variable en dos lugares y podrías olvidarte de actualizar uno. Puedes evitar este tipo de repetición pasando un conjunto de mapeos a ggplot(). ggplot2 tratará estos mapeos como **mapeos globales* que se aplican a cada geom en el gráfico. En otras palabras, este código producirá la misma gráfica que el código anterior:\n\n\nCode\nggplot(data = millas, mapping = aes(x = cilindrada, y = autopista)) +\n  geom_point() +\n  geom_smooth()\n\n\n`geom_smooth()` using method = 'loess' and formula = 'y ~ x'\n\n\n\n\n\nSi colocas mapeos en una función geom, ggplot2 los tratará como mapeos locales para la capa. Estas asignaciones serán usadas para extender o sobrescribir los mapeos globales solo para esa capa. Esto permite mostrar diferentes estéticas en diferentes capas.\n\n\nCode\nggplot(data = millas, mapping = aes(x = cilindrada, y = autopista)) +\n  geom_point(mapping = aes(color = clase)) +\n  geom_smooth()\n\n\n`geom_smooth()` using method = 'loess' and formula = 'y ~ x'\n\n\n\n\n\nLa misma idea se puede emplear para especificar distintos conjuntos de datos (data) para cada capa. En el siguiente caso, nuestra línea suave muestra solo un subconjunto del conjunto de datos de millas: los autos subcompactos. El argumento local de datos en geom_smooth() anula el argumento de datos globales en ggplot() solo para esa capa.\n\n\nCode\nggplot(data = millas, mapping = aes(x = cilindrada, y = autopista)) +\n  geom_point(mapping = aes(color = clase)) +\n  geom_smooth(data = filter(millas, clase == \"subcompacto\"), se = FALSE)\n\n\n`geom_smooth()` using method = 'loess' and formula = 'y ~ x'\n\n\n\n\n\nEjercicios\n- ¿Qué geom usarías para generar un gráfico de líneas? ¿Y para un diagrama de caja? ¿Y para un histograma? ¿Y para un gráfico de área?\n- Ejecuta este código en tu mente y predice cómo se verá el output. Luego, ejecuta el código en R y verifica tus predicciones.\n\n\nCode\nggplot(data = millas, mapping = aes(x = cilindrada, y = autopista, color = traccion)) +\n  geom_point() +\n  geom_smooth(se = FALSE)\n\n\n- ¿Qué muestra show.legend = FALSE? ¿Qué pasa si lo quitas? ¿Por qué crees que lo utilizamos antes en el capítulo?\n- ¿Qué hace el argumento se en geom_smooth()?\n- ¿Se verán distintos estos gráficos? ¿Por qué sí o por qué no?\n\n\nCode\nggplot(data = millas, mapping = aes(x = cilindrada, y = autopista)) +\n  geom_point() +\n  geom_smooth()\nggplot() +\n  geom_point(data = millas, mapping = aes(x = cilindrada, y = autopista)) +\n  geom_smooth(data = millas, mapping = aes(x = cilindrada, y = autopista))\n\n\n- Recrea el código R necesario para generar los siguientes gráficos:"
  },
  {
    "objectID": "c04_tidyverse_3.html#transformaciones-estadísticas",
    "href": "c04_tidyverse_3.html#transformaciones-estadísticas",
    "title": "6  Gráficos en R",
    "section": "6.6 Transformaciones estadísticas",
    "text": "6.6 Transformaciones estadísticas\nA continuación, echemos un vistazo a un gráfico de barras. Los gráficos de barras parecen simples, pero son interesantes porque revelan algo sutil sobre los gráficos. Considera un gráfico de barras básico, como uno realizado con geom_bar(). El siguiente gráfico muestra la cantidad total de diamantes en el conjunto de datos diamantes, agrupados por la variable corte. El conjunto de datos diamantes se encuentra en el paquete datos y contiene información sobre ~ 54000 diamantes, incluido el precio, el quilate, el color, la claridad y el corte de cada uno. El gráfico muestra que hay más diamantes disponibles con cortes de alta calidad que con cortes de baja calidad.\n\n\nCode\nggplot(data = diamantes) +\n  geom_bar(mapping = aes(x = corte))\n\n\n\n\n\nEn el eje x, el gráfico muestra corte, una variable de diamantes. En el eje y muestra el recuento (count), ¡pero el recuento no es una variable en diamantes! ¿De dónde viene? Muchos gráficos, como los diagramas de dispersión (scatterplots), grafican los valores brutos de un conjunto de datos. Otros gráficos, como los de barras, calculan nuevos valores para presentar:\n\nLos gráficos de barras, los histogramas y los polígonos de frecuencia almacenan los datos y luego grafican los conteos por contenedores (bins), es decir, el número de puntos que caen en cada contenedor.\nLos gráficos de líneas suavizadas (smoothers) ajustan un modelo a los datos y luego grafican las predicciones del modelo.\nLos diagramas de caja (boxplots) calculan un resumen robusto de la distribución y luego muestran una caja con formato especial.\n\nEl algoritmo utilizado para calcular nuevos valores para un gráfico se llama stat, abreviatura en inglés de transformación estadística (statistical transformation). La siguiente figura describe cómo funciona este proceso con geom_bar().\n\n\n\nPuedes aprender acerca de qué stat usa cada geom inspeccionando el valor predeterminado para el argumento stat. Por ejemplo, ?geom_bar muestra que el valor predeterminado para stat es “count”, lo que significa que geom_bar() usa stat_count(). stat_count() está documentado en la misma página que geom_bar() y si te desplazas hacia abajo puedes encontrar una sección llamada “Computed variables” (Variables calculadas). Ahí se describe cómo calcula dos nuevas variables: count y prop.\nPor lo general, puedes usar geoms y estadísticas de forma intercambiable. Por ejemplo, puedes volver a crear la gráfica anterior usando stat_count() en lugar de geom_bar():\n\n\nCode\nggplot(data = diamantes) +\n  stat_count(mapping = aes(x = corte))\n\n\n\n\n\nEsto funciona porque cada geom tiene una estadística predeterminada y cada estadística tiene un geom predeterminado. Esto significa que generalmente puedes usar geoms sin preocuparte por la transformación estadística subyacente.\nHay tres razones por las que podrías necesitar usar una estadística explícitamente:\n\nEs posible que desees anular la estadística predeterminada. En el siguiente código, cambiamos en geom_bar() la estadística recuento (“count”, el valor predeterminado) a identidad (“identity”). Esto nos permite asignar la altura de las barras a los valores brutos de una variable y. Desafortunadamente, cuando las personas hablan de gráficos de barras de manera informal, podrían estar refiriéndose a este tipo de gráfico de barras, en el que la altura de la barra ya está presente en los datos, o bien, al gráfico de barras anterior, en el que la altura de la barra se determina contando filas.\n\n\n\nCode\ndemo <- tribble(\n  ~corte,     ~freq,\n  \"Regular\",   1610,\n  \"Bueno\",     4906,\n  \"Muy Bueno\", 12082,\n  \"Premium\",   13791,\n  \"Ideal\",     21551\n)\nggplot(data = demo) +\n  geom_bar(mapping = aes(x = corte, y = freq), stat = \"identity\")\n\n\n\n\n\n(No te preocupes si nunca has visto <- o tribble(). Puede que seas capaz de adivinar su significado por el contexto y ¡pronto aprenderás qué es lo que hacen exactamente!)\n\nEs posible que desees anular el mapeo predeterminado de las variables transformadas a las estéticas. Por ejemplo, es posible que desees mostrar un gráfico de barras de proporciones, en lugar de un recuento:\n\n\n\nCode\nggplot(data = diamantes) +\n  geom_bar(mapping = aes(x = corte, y = stat(prop), group = 1))\n\n\nWarning: `stat(prop)` was deprecated in ggplot2 3.4.0.\nℹ Please use `after_stat(prop)` instead.\n\n\n\n\n\nPara encontrar las variables calculadas por stat, busca la sección de ayuda titulada “Compute Variables”.\n\nEs posible que desees resaltar la transformación estadística en tu código. Por ejemplo, puedes usar stat_summary(), que resume los valores de y para cada valor único de x, para así resaltar el resumen que se está computando:\n\n\n\nCode\nggplot(data = diamantes) +\n  stat_summary(\n    mapping = aes(x = corte, y = profundidad),\n    fun.min = min,\n    fun.max = max,\n    fun = median\n  )\n\n\n\n\n\nggplot2 proporciona más de 20 transformaciones estadísticas para que uses. Cada stat es una función, por lo que puedes obtener ayuda de la manera habitual, por ejemplo: ?stat_bin. Para ver una lista completa de transformaciones estadísticas disponibles para ggplot2, consulta la hoja de referencia.\nEjercicios\n- ¿Cuál es el geom predeterminado asociado con stat_summary()? ¿Cómo podrías reescribir el gráfico anterior para usar esa función geom en lugar de la función stat?\n- ¿Qué hace geom_col()? ¿En qué se diferencia de geom_bar()?\n- La mayoría de los geoms y las transformaciones estadísticas vienen en pares que casi siempre se usan en conjunto. Lee la documentación y haz una lista de todos los pares. ¿Qué tienen en común?\n- ¿Qué variables calcula stat_smooth()? ¿Qué parámetros controlan su comportamiento?\n- En nuestro gráfico de barras de proporción necesitamos establecer group = 1. ¿Por qué? En otras palabras, ¿cuál es el problema con estos dos gráficos?\n\n\nCode\nggplot(data = diamantes) +\n  geom_bar(mapping = aes(x = corte, y = after_stat(prop))\nggplot(data = diamantes) +\n  geom_bar(mapping = aes(x = corte, fill = color, y = after_stat(prop))"
  },
  {
    "objectID": "c04_tidyverse_3.html#ajustes-de-posición",
    "href": "c04_tidyverse_3.html#ajustes-de-posición",
    "title": "6  Gráficos en R",
    "section": "6.7 Ajustes de posición",
    "text": "6.7 Ajustes de posición\nHay una pieza más de magia asociada con los gráficos de barras. Puedes colorear un gráfico de barras usando tanto la estética de color como la más útil fill (relleno):\n\n\nCode\nggplot(data = diamantes) +\n  geom_bar(mapping = aes(x = corte, colour = corte))\n\n\n\n\n\nCode\nggplot(data = diamantes) +\n  geom_bar(mapping = aes(x = corte, fill = corte))\n\n\n\n\n\nMira lo que sucede si asignas la estética de relleno (fill) a otra variable, como claridad: las barras se apilan automáticamente. Cada rectángulo de color representa una combinación de corte y claridad.\n\n\nCode\nggplot(data = diamantes) +\n  geom_bar(mapping = aes(x = corte, fill = claridad))\n\n\n\n\n\nEl apilamiento se realiza automáticamente mediante el ajuste de posición especificado por el argumento position. Si no deseas un gráfico de barras apiladas (“stack”), puedes usar una de las otras tres opciones: “identity”, “dodge” o “fill”.\n\nposition = “identity” colocará cada objeto exactamente donde cae en el contexto del gráfico. Esto no es muy útil al momento de graficar barras, ya que las superpone. Para ver esa superposición, debemos hacer que las barras sean ligeramente transparentes configurando el alpha a un valor pequeño, o completamente transparente al establecer fill = NA.\n\n\n\nCode\nggplot(data = diamantes, mapping = aes(x = corte, fill = claridad)) +\n  geom_bar(alpha = 1/5, position = \"identity\")\n\n\n\n\n\nCode\nggplot(data = diamantes, mapping = aes(x = corte, colour = claridad)) +\n  geom_bar(fill = NA, position = \"identity\")\n\n\n\n\n\nEl ajuste de position = identity es más útil para geoms 2D, como puntos, donde es la opción predeterminada.\n\nposition = “fill” funciona como el apilamiento de position = “stack”, pero hace que cada conjunto de barras apiladas tenga la misma altura. Esto hace que sea más fácil comparar proporciones entre grupos.\n\n\n\nCode\nggplot(data = diamantes) +\n  geom_bar(mapping = aes(x = corte, fill = claridad), position = \"fill\")\n\n\n\n\n\n\nposition = “dodge” coloca los objetos superpuestos uno al lado del otro. Esto hace que sea más fácil comparar valores individuales.\n\n\n\nCode\nggplot(data = diamantes) +\n  geom_bar(mapping = aes(x = corte, fill = claridad), position = \"dodge\")\n\n\n\n\n\nHay otro tipo de ajuste que no es útil para gráficos de barras, pero que puede ser muy útil para diagramas de dispersión. Recuerda nuestro primer diagrama de dispersión. ¿Notaste que mostraba solo 126 puntos, a pesar de que hay 234 observaciones en el conjunto de datos?\n\n\n\nLos valores de las variables autopista y cilindrada se redondean de modo que los puntos aparecen en una cuadrícula y muchos se superponen entre sí. Este problema se conoce como solapamiento (overplotting). Esta disposición hace que sea difícil ver dónde está la masa de datos. ¿Los puntos de datos se distribuyen equitativamente a lo largo de la gráfica, o hay una combinación especial de autopista y cilindrada que contiene 109 valores?\nPuedes evitar esto estableciendo el ajuste de posición en “jitter”. position = “jitter” agrega una pequeña cantidad de ruido aleatorio a cada punto. Esto dispersa los puntos, ya que es poco probable que dos puntos reciban la misma cantidad de ruido aleatorio.\n\n\nCode\nggplot(data = millas) +\n  geom_point(mapping = aes(x = cilindrada, y = autopista), position = \"jitter\")\n\n\n\n\n\nAgregar aleatoriedad a los puntos puede parecer una forma extraña de mejorar tu gráfico. Si bien hace que sea menos preciso a escalas pequeñas, lo hace ser más revelador a gran escala. Como esta es una operación tan útil, ggplot2 incluye una abreviatura de geom_point(position = “jitter”): geom_jitter().\nPara obtener más información sobre ajustes de posición, busca la página de ayuda asociada con cada ajuste: ?position_dodge, ?position_fill, ?position_identity, ?position_jitter y ?position_stack.\nEjercicios\n- ¿Cuál es el problema con este gráfico? ¿Cómo podrías mejorarlo?\n\n\nCode\nggplot(data = millas, mapping = aes(x = ciudad, y = autopista)) +\n  geom_point()\n\n\n\n\n\n- ¿Qué parámetros de geom_jitter() controlan la cantidad de ruido?\n- Compara y contrasta geom_jitter() con geom_count()\n- ¿Cuál es el ajuste de posición predeterminado de geom_boxplot()? Crea una visualización del conjunto de datos de millas que lo demuestre."
  },
  {
    "objectID": "c04_tidyverse_3.html#sistemas-de-coordenadas",
    "href": "c04_tidyverse_3.html#sistemas-de-coordenadas",
    "title": "6  Gráficos en R",
    "section": "6.8 Sistemas de coordenadas",
    "text": "6.8 Sistemas de coordenadas\nLos sistemas de coordenadas son probablemente la parte más complicada de ggplot2. El sistema predeterminado es el sistema de coordenadas cartesianas, donde las posiciones x e y actúan independientemente para determinar la ubicación de cada punto. Hay varios otros sistemas de coordenadas que ocasionalmente son útiles.\n\ncoord_flip() cambia los ejes x e y. Esto es útil, por ejemplo, si quieres diagramas de caja horizontales. También es útil para etiquetas largas: es difícil ajustarlas sin que se superpongan en el eje x.\n\n\n\nCode\nggplot(data = millas, mapping = aes(x = clase, y = autopista)) +\n  geom_boxplot()\n\n\n\n\n\nCode\nggplot(data = millas, mapping = aes(x = clase, y = autopista)) +\n  geom_boxplot() +\n  coord_flip()\n\n\n\n\n\n\ncoord_quickmap() establece correctamente la relación de aspecto para los mapas. Esto es muy importante si graficas datos espaciales con ggplot2 (tema para el que, desafortunadamente, no contamos con espacio para desarrollar en este libro).\n\n\n\nCode\nnz <- map_data(\"nz\")\nggplot(nz, aes(long, lat, group = group)) +\n  geom_polygon(fill = \"white\", colour = \"black\")\n\n\n\n\n\nCode\nggplot(nz, aes(long, lat, group = group)) +\n  geom_polygon(fill = \"white\", colour = \"black\") +\n  coord_quickmap()\n\n\n\n\n\n\ncoord_polar() usa coordenadas polares. Las coordenadas polares revelan una conexión interesante entre un gráfico de barras y un gráfico de Coxcomb.\n\n\n\nCode\nbar <- ggplot(data = diamantes) +\n  geom_bar(\n    mapping = aes(x = corte, fill = corte),\n    show.legend = FALSE,\n    width = 1\n  ) +\n  theme(aspect.ratio = 1) +\n  labs(x = NULL, y = NULL)\nbar + coord_flip()\n\n\n\n\n\nCode\nbar + coord_polar()\n\n\n\n\n\nEjercicios\n- Convierte un gráfico de barras apiladas en un gráfico circular usando coord_polar().\n- ¿Qué hace labs()? Lee la documentación.\n- ¿Cuál es la diferencia entre coord_quickmap() y coord_map()?\n- ¿Qué te dice la gráfica siguiente sobre la relación entre ciudad y autopista? ¿Por qué es coord_fixed() importante? ¿Qué hace geom_abline()?\n\n\nCode\nggplot(data = millas, mapping = aes(x = ciudad, y = autopista)) +\n  geom_point() +\n  geom_abline() +\n  coord_fixed()"
  },
  {
    "objectID": "c04_tidyverse_3.html#la-gramática-de-gráficos-en-capas",
    "href": "c04_tidyverse_3.html#la-gramática-de-gráficos-en-capas",
    "title": "6  Gráficos en R",
    "section": "6.9 La gramática de gráficos en capas",
    "text": "6.9 La gramática de gráficos en capas\nEn las secciones anteriores aprendiste mucho más que solo hacer diagramas de dispersión, gráficos de barras y diagramas de caja. Aprendiste una base que se puede usar para hacer cualquier tipo de gráfico con ggplot2. Para ver esto, agreguemos ajustes de posición, transformaciones estadísticas, sistemas de coordenadas y facetas a nuestra plantilla de código:\n\n\nCode\nggplot(data = <DATOS>) +\n <GEOM_FUNCIÓN>(\n   mapping = aes(<MAPEOS>),\n   stat = <ESTADÍSTICAS>,\n   position = <POSICIÓN>\n ) +\n <FUNCIÓN_COORDENADAS> +\n <FUNCIÓN_FACETAS>\n\n\nNuestra nueva plantilla tiene siete parámetros que se corresponden con las palabras entre corchetes que aparecen en la plantilla. En la práctica, rara vez necesitas proporcionar los siete parámetros para hacer un gráfico porque ggplot2 proporcionará valores predeterminados útiles para todos, excepto para los datos, el mapeo y la función geom.\nLos siete parámetros en la plantilla componen la gramática de los gráficos, un sistema formal de construcción de gráficos. La gramática de los gráficos se basa en la idea de que puedes describir de manera única cualquier gráfico como una combinación de un conjunto de datos, un geom, un conjunto de mapeos, una estadística, un ajuste de posición, un sistema de coordenadas y un esquema de facetado.\nPara ver cómo funciona esto, considera cómo podrías construir un gráfico básico desde cero: podrías comenzar con un conjunto de datos y luego transformarlo en la información que deseas mostrar (con un stat).\n\n\n\nA continuación, podrías elegir un objeto geométrico para representar cada observación en los datos transformados. Luego, podrías usar las propiedades estéticas de los geoms para representar variables de los datos. Asignarías los valores de cada variable a los niveles de una estética.\n\n\n\nPosteriormente, podrías seleccionar un sistema de coordenadas para colocar los geoms. Podrías utilizar la ubicación de los objetos (que es en sí misma una propiedad estética) para mostrar los valores de las variables x e y. Ya en este punto podrías tener un gráfico completo, pero también podrías ajustar aún más las posiciones de los geoms dentro del sistema de coordenadas (un ajuste de posición) o dividir el gráfico en facetas. También podrías extender el gráfico agregando una o más capas adicionales, donde cada capa adicional usaría un conjunto de datos, un geom, un conjunto de mapeos, una estadística y un ajuste de posición.\n\n\n\nPuedes usar este método para construir cualquier gráfico que imagines. En otras palabras, puedes usar la plantilla de código que aprendiste en este capítulo para construir cientos de miles de gráficos únicos."
  },
  {
    "objectID": "c05_spatial.html#datos-vectoriales",
    "href": "c05_spatial.html#datos-vectoriales",
    "title": "7  Introducción a datos espaciales",
    "section": "7.1 Datos Vectoriales",
    "text": "7.1 Datos Vectoriales\n\nLos datos vectoriales son usados para representar espacialmente el mundo real y las variables asociadas a estas. Un objeto espacial vectorial puede ser de geometría tipo punto, línea o un polígono. Cada objeto espacial vectorial tienen datos de atributos que lo describen."
  },
  {
    "objectID": "c05_spatial.html#datos-raster",
    "href": "c05_spatial.html#datos-raster",
    "title": "7  Introducción a datos espaciales",
    "section": "7.2 Datos Raster",
    "text": "7.2 Datos Raster\n\nEn su forma más simple, un ráster consta de una matriz de celdas (o píxeles) organizadas en filas y columnas (o una cuadrícula) en la que cada celda contiene un valor que representa información, como la temperatura. Los rásteres son fotografías aéreas digitales, imágenes de satélite, imágenes digitales o incluso mapas escaneados."
  },
  {
    "objectID": "c05_spatial.html#qué-es-ogc",
    "href": "c05_spatial.html#qué-es-ogc",
    "title": "7  Introducción a datos espaciales",
    "section": "7.3 ¿Qué es OGC?",
    "text": "7.3 ¿Qué es OGC?\n\nEl Open Geospatial Consortium (OGC) es una organización sin fines de lucro que fue fundado en 1994 para hacer de la información geográfica una parte integral de la infraestructura mundial de información. Agrupa (en mayo de 2019) a 527 miembros de organizaciones públicas y privadas (más información en https://www.ogc.org/ogc/members ). Los miembros de OGC (usuarios y proveedores de tecnología) desarrollan de forma colaborativa estándares de interfaz y los estándares asociados, así como buenas prácticas, que permiten a los desarrolladores crear sistemas de información que pueden fácilmente intercambiar información geográfica e instrucciones con otros sistemas de información. Los requisitos varían desde planificaciones complejas y control de satélites de observación terrestre a la visualización de sencillas imágenes cartográficas en la web, así como la codificación de la localización en apenas unos pocos bytes para geoetiquetado y mensajería. Un vistazo a los OGC Domain Working Groups (http://www.opengeospatial.org/projects/groups/wg) muestra el amplio espectro de la actividad actual en OGC."
  },
  {
    "objectID": "c05_spatial.html#qué-es-osgeo",
    "href": "c05_spatial.html#qué-es-osgeo",
    "title": "7  Introducción a datos espaciales",
    "section": "7.4 ¿Qué es OSGeo?",
    "text": "7.4 ¿Qué es OSGeo?\n\nOpen Source Geospatial Foundation, es una organización no gubernamental sin fines de lucro cuya misión es apoyar y promover el desarrollo colaborativo de software, datos y educación geoespacial de código abierto.\n\n\nLos proyectos mostrados en la siguiente figura ofrecen herramientas y tecnologías disponibles gratuitamente bajo una licencia de código abierto. Esta lista promueve el trabajo de equipos y organizaciones en todo el mundo. Los proyectos marcados como OSGeo Community se han unido a OSGeo, mientras que los marcados como OSGeo Project han sido objeto de una extensa tutoría con esta organización."
  },
  {
    "objectID": "c05_spatial.html#qué-es-gdal",
    "href": "c05_spatial.html#qué-es-gdal",
    "title": "7  Introducción a datos espaciales",
    "section": "7.5 ¿Qué es GDAL?",
    "text": "7.5 ¿Qué es GDAL?\n\nGeospatial Data Abstraction Library (GDAL/OGR) proporciona herramientas de línea de comandos para traducir y procesar una amplia gama de formatos de datos geoespaciales ráster y vectoriales.\n\n\nSus herramientas se basan en una biblioteca multiplataforma escrita en C ++, accesible a través de numerosos lenguajes de programación. Como biblioteca, presenta un único modelo de datos abstracto a la aplicación que realiza la llamada para todos los formatos admitidos.\n\n\nGDAL/OGR es la biblioteca de acceso a datos geoespaciales más ampliamente utilizada. Proporciona el motor principal de acceso a datos para muchas aplicaciones, incluyendo MapServer, GRASS, QGIS y OpenEV. También es utilizado por paquetes como OSSIM, Cadcorp SIS, FME, Google Earth, VTP, Thuban, ILWIS, MapGuide y ArcGIS.\n\n\n\n\nCaracterísticas Principales\n\nSu última versión es la 3.3.1.\nEs un software libre de código abierto, licenciado bajo una licencia de estilo MIT/X.\nCon la versión GDAL 2.0, se integraron los componentes GDAL y OGR.\nCompatible con sistemas operativos como Windows, IOS y UNIX.\nUtilidades de línea de comandos para la traducción de datos, deformación de imagen, subconjunto y otras tareas comunes.\nAcceso a datos ráster altamente eficiente, aprovechando el mosaico y las vistas generales.\nSoporte para archivos de gran tamaño - más de 4 GB.\nAcceso a la biblioteca desde Python, Java, C#, Ruby, VB6 y Perl.\nMotor de sistema de coordenadas basado en PROJ.4 y descripciones de sistema de coordenadas con Well Known Text (WKT) de OGC.\n\nFormatos Popularmente Compatibles\nGDAL soporta más de 140 formatos ráster y OGR con más de 80 formatos de vector.\nÉstas incluyen:\n\nRaster: GeoTIFF, Erdas Imagine, SDTS, ESRI Grids, ECW, MrSID, JPEG2000, DTED, NITF, GeoPackage y más …\nVector: GeoPackage, ESRI Shapefile, GML, GeoJSON, AutoCAD DWG, MapInfo (tab y mid / mif), ESRI Coverage, ESRI Personal Geodatabase, DGN, PostGIS, Oracle Spatial, y más …"
  },
  {
    "objectID": "c05_spatial.html#qué-es-proj",
    "href": "c05_spatial.html#qué-es-proj",
    "title": "7  Introducción a datos espaciales",
    "section": "7.6 ¿Qué es Proj?",
    "text": "7.6 ¿Qué es Proj?\n\nPROJ es un software de transformación de coordenadas genérico que transforma las coordenadas geoespaciales de un sistema de referencia de coordenadas (CRS) a otro. Esto incluye proyecciones cartográficas y transformaciones geodésicas.\n\n\nPROJ incluye aplicaciones de línea de comandos para una fácil conversión de coordenadas de archivos de texto o directamente desde la entrada del usuario. Además de las utilidades de la línea de comandos, PROJ también expone una interfaz de programación de aplicaciones, o API en resumen. La API permite a los desarrolladores usar la funcionalidad de PROJ en su propio software sin tener que implementar una funcionalidad similar ellos mismos.\n\n\nPROJ comenzó simplemente como una aplicación de cartografía que permitía a los usuarios convertir coordenadas geodésicas en coordenadas proyectadas utilizando una serie de proyecciones cartográficas diferentes. A lo largo de los años, a medida que la necesidad se ha hecho evidente, el apoyo para cambios de datum también se ha abierto camino lentamente en PROJ. Actualmente, PROJ admite más de cien proyecciones de mapas diferentes y puede transformar coordenadas entre datums utilizando todas las técnicas geodésicas, excepto las más oscuras.\n\nPara obtener más información, visite el sitio web del proyecto o consulte su documentación en formato PDF."
  }
]