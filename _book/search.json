[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Taller de programación R - SERNANP",
    "section": "",
    "text": "1 Presentación\nEl SERNANP brinda el servicio de mantener áreas protegidas en buen estado de conservación para asegurar la provisión de servicios ambientales que generen bienestar a poblaciones. Uno de los pilares para alcanzar dicha eficiencia es gestionar la información espacial generada en el interior de las áreas, así como información externa de aliados estratégicos y demás instiuciones que contribuyen al desarrollo del medio ambiente.\nEste taller tiene el objetivo de servir como herramienta para la gestión de información y pueda ser insumo para la toma de decisiones que lleven a implementar acciones con el fin de contribuir con el mantenimiento del buen estado de conservación de las ANP."
  },
  {
    "objectID": "c01_introduccion.html#lenguajes-de-programación",
    "href": "c01_introduccion.html#lenguajes-de-programación",
    "title": "2  Introducción a los lenguajes de programación",
    "section": "2.1 Lenguajes de programación",
    "text": "2.1 Lenguajes de programación\nUn lenguaje de programación es una forma de comunicarnos con una computadora e indicarle qué queremos hacer. En otras palabras, nos permitirá darle instrucciones y reglas que permiten crear herramientas, programas, realizar análisis o tareas específicas.\nExisten distintos tipos de lenguaje, según la conexión entre el software y hardware podemos diferenciarlos en lenguajes bajo nivel y de alto nivel. La diferencia se encuentra en lo cerca o lejos que estemos del hardware de nuestro equipo.\nAdemás, podemos diferenciarlos según el propósito o el modo de uso, aquellos que están orientados al desarrollo y aquellos que están orientados al análisis. Los lenguajes orientados al desarrollo se utilizan para crear aplicaciones y programas, mientras que los lenguajes orientados al análisis se utilizan para procesar y analizar datos.\n\n\n\nLenguajes de programación"
  },
  {
    "objectID": "c01_introduccion.html#qué-es-r",
    "href": "c01_introduccion.html#qué-es-r",
    "title": "2  Introducción a los lenguajes de programación",
    "section": "2.3 ¿Qué es R?",
    "text": "2.3 ¿Qué es R?\nR es un lenguaje de programación y entorno computacional dedicado a la estadística que proporciona un amplio abanico de herramientas estadísticas (modelos lineales y no lineales, tests estadísticos, análisis de series temporales, algoritmos de clasificación y agrupamiento, etc.)\nPermite definir funciones propias. De hecho, gran parte de las funciones de R están escritas en el mismo R, aunque para algoritmos computacionalmente exigentes es posible desarrollar bibliotecas en C, C++ o Fortran que se cargan dinámicamente.\nR puede integrarse con distintas bases de datos y existen bibliotecas que facilitan su utilización desde lenguajes de programación interpretados como Python (PythonInR), hereda de S su orientación a objetos.\nOtra de las características de R es su capacidad gráfica, que permite generar gráficos con alta calidad (ggplot). R posee su propio formato para la documentación basado en LaTeX."
  },
  {
    "objectID": "c01_introduccion.html#qué-es-rstudio",
    "href": "c01_introduccion.html#qué-es-rstudio",
    "title": "2  Introducción a los lenguajes de programación",
    "section": "2.4 ¿Qué es RStudio?",
    "text": "2.4 ¿Qué es RStudio?\nRStudio es un editor para scripts disponible para usuarios de R en todos los sistemas operativos. Es considerado como un entorno de desarrollo integrado (GUI)que combina un interfaz muy intuitiva con herramientas de código muy potentes que permiten sacar el máximo provecho a R.\nLa ventaja de este editor es que ofrece una serie de opciones no existentes en R, entre otras, por ejemplo, comprobar rápidamente que ningún paréntesis queda sin cerrarse o marcar, copiar y pegar columnas.\nPero además nos da un listado de las variables y nos da una descripción de los bancos de datos que hemos introducido. También tiene una lista de los paquetes instalados y los gráficos realizados."
  },
  {
    "objectID": "c01_introduccion.html#qué-otros-ides-existen-para-r",
    "href": "c01_introduccion.html#qué-otros-ides-existen-para-r",
    "title": "2  Introducción a los lenguajes de programación",
    "section": "2.5 ¿Qué otros IDE’s existen para R?",
    "text": "2.5 ¿Qué otros IDE’s existen para R?\n\nTinn-R\nRKward\nRcommander\nJupyter notebook\nVisual studio code\nPycharm\nEclipse"
  },
  {
    "objectID": "c01_introduccion.html#instalación-de-r-rstudio-y-rtools",
    "href": "c01_introduccion.html#instalación-de-r-rstudio-y-rtools",
    "title": "2  Introducción a los lenguajes de programación",
    "section": "2.6 Instalación de R, RStudio y RTools",
    "text": "2.6 Instalación de R, RStudio y RTools\n\n2.6.1 R y RStudio\nPrimero deberá descargar e instalar R y luego RStudio.\nInstalación de R\nPara instalar R hay que bajar un fichero ejecutable de la página web del proyecto R: http://www.r-project.org/. Actualmente (Marzo 2023), la versión más reciente de R para el entorno Windows es la 4.2.3 y el ejecutable de tamaño aproximadamente 77Mb tiene el nombre R-4.2.3-win.exe.\nInstalación de RStudio\nPara instalar RStudio nos dirigimos al enlace http://www.rstudio.org/,la versión en pruebas es gratuita.Una vez bajado este ejecutable, hay que ejecutarlo y seguir las instrucciones del programa de instalación.\n\n\n2.6.2 RTools\nEs un paquete de herramientas para construir paquetes de R. Esto es lo que desea para construir sus propios paquetes en Windows, o para construir R por sí mismo. A partir de R 4.3.0 (2023), R para Windows usa un paquete de cadena de herramientas llamado rtools43.\nEsta versión de Rtools incluye gcc 8.3.0 e introduce un nuevo sistema de compilación basado en msys2`, que facilita la compilación y el mantenimiento de R, así como las bibliotecas del sistema que necesitan los paquetes de R en Windows. Las compilaciones recientes de rtools43 también contienen una cadena de herramientas adicional gcc-10 ucrt para probar paquetes de R y bibliotecas del sistema con las compilaciones ucrt experimentales de R-devel."
  },
  {
    "objectID": "c01_introduccion.html#tipos-de-lenguajes-de-programación",
    "href": "c01_introduccion.html#tipos-de-lenguajes-de-programación",
    "title": "2  Introducción a los lenguajes de programación",
    "section": "2.7 Tipos de lenguajes de programación",
    "text": "2.7 Tipos de lenguajes de programación\n\n2.7.1 Lenguaje compilado\nSon aquellos lenguajes de alto nivel que como su nombre lo sugiere, requieren de un compilador (programa que traduce un lenguaje de alto nivel en código máquina o lenguaje máquina) para traducirlo y crear la parte ejecutable.\n\nC++\nGo\n\n\n\n2.7.2 Lenguaje interpretado\nSon aquellos lenguajes de programación también de alto nivel en donde el código fuente debe ser traducido a un lenguaje que la máquina entienda y pueda realizar, no crean un archivo externo.\n\nRuby\nJavascript\nPython\nR\n\nLos lenguajes de alto nivel permiten escribir instrucciones en un idioma muy parecido al inglés así como hacer uso de notaciones matemáticas comunes.\n\n\n2.7.3 Lenguaje intermedio\nLos lenguajes intermedios son compilados hacia programas intermedios y luego interpretados, esto permite que pueda ser ejecutado desde cualquier sistema operativo sin necesidad de crear ejecutables.\n\nJava\nC#"
  },
  {
    "objectID": "c01_introduccion.html#paradigmas-de-programación",
    "href": "c01_introduccion.html#paradigmas-de-programación",
    "title": "2  Introducción a los lenguajes de programación",
    "section": "2.8 Paradigmas de programación",
    "text": "2.8 Paradigmas de programación\nUn paradigma de programación es una manera o estilo de programación de software. Se trata de un conjunto de métodos sistemáticos aplicables en todos los niveles del diseño de programas para resolver problemas computacionales.\n\n2.8.1 Programación Orientado a Objetos\nSe construyen modelos de objetos que representan elementos (objetos) del problema a resolver, que tienen características y funciones. Permite separar los diferentes componentes de un programa, simplificando así su creación, depuración y posteriores mejoras. La programación orientada a objetos disminuye los errores y promociona la reutilización del código. Es una manera especial de programar, que se acerca de alguna manera a cómo expresaríamos las cosas en la vida real.\n\n\n2.8.2 Programación Funcional\nLa programación funcional es un paradigma declarativo. Nos enfocaremos en “qué” estamos haciendo y no en “cómo” se está haciendo que sería el enfoque imperativo. Esto quiere decir que se expresa nuestra lógica sin describir controles de flujo, ni ciclos ni condicionales."
  },
  {
    "objectID": "c01_introduccion.html#ambiente-de-trabajo-en-rstudio",
    "href": "c01_introduccion.html#ambiente-de-trabajo-en-rstudio",
    "title": "2  Introducción a los lenguajes de programación",
    "section": "2.9 Ambiente de trabajo en RStudio",
    "text": "2.9 Ambiente de trabajo en RStudio\nLa interfaz gráfica de RStudio nos permite acceder a scripts, datos, encontrar ayuda y previsualizar gráficos y resultados."
  },
  {
    "objectID": "c02_intro_R.html#tipos-de-estructuras-de-datos",
    "href": "c02_intro_R.html#tipos-de-estructuras-de-datos",
    "title": "3  Introducción a R",
    "section": "3.3 Tipos de estructuras de datos",
    "text": "3.3 Tipos de estructuras de datos\n\n\n\n\n\n\n\n\nObjetos\nTipos\n¿Soporta varios tipos de datos en el mismo objeto?\n\n\n\n\nVector\nNumérico, carácter, complejo o lógico\nNo\n\n\nFactor\nNumérico o lógico\nNo\n\n\nArreglo\nNumérico, carácter, complejo o lógico\nNo\n\n\nMatriz\nNumérico, carácter, complejo o lógico\nNo\n\n\nData frame\nNumérico, carácter, complejo o lógico\nSí\n\n\nts\nNumérico, carácter, complejo o lógico\nSí\n\n\nLista\nNumérico, carácter, complejo, lógico, función, expresión, …\nSí"
  },
  {
    "objectID": "c02_intro_R.html#comience-a-codificar",
    "href": "c02_intro_R.html#comience-a-codificar",
    "title": "3  Primeros pasos en R",
    "section": "3.4 Comience a codificar",
    "text": "3.4 Comience a codificar\nComenzamos a codificar imprimiendo Hello worldy posteriormente asignando valores a un objeto\n\n\nCode\nprint(\"Hello world\")\n\n\n\n3.4.1 Asignación de objetos\n\n\nCode\nobj <- c(5, 2, 6, 58, 456, 56, 5)\nc(5, 2, 6, 58, 456, 56, 5) -> obj"
  },
  {
    "objectID": "c02_intro_R.html#conceptos-básicos-de-r",
    "href": "c02_intro_R.html#conceptos-básicos-de-r",
    "title": "3  Primeros pasos en R",
    "section": "3.5 Conceptos Básicos de R",
    "text": "3.5 Conceptos Básicos de R\n\n3.5.1 Espacio y directorio de trabajo\n\n\n\n\n\n\n\nFunción\nAcción\n\n\n\n\ngetwd()\nMuestra el wd: working directory\n\n\nsetwd(\"midirectorio\")\nAjusta el wd al especificado\n\n\nls()  o dir()\nLista lo que hay en el wd\n\n\nhistory()\nMuestra los últimos comandos ejecutados\n\n\nsavehistory()\nGuarda el historial de comandos, por defecto en .Rhistory\n\n\nloadhistory()\nCarga el historial de comandos\n\n\nsave.image(\"mywspace.R\")\nGuarda los objetos del workspace, por defecto en .Rdata\n\n\nload(\"mywspace.R\")\nCarga el workspace mywspace.R\n\n\n\n\n\n3.5.2 Vector\n\nEs el elemento más básico en R.\nContiene elementos de la misma clase (son atómicos).\nSe crea con la función c(), que significa ‘concatenar’ o ‘combinar’.\n\n\n\nCode\nvector01 <- c(1, 2, 4, 7, 10, 11, 12, 19, 26)\nvector02 <- c(\"a\", \"b\", \"d\", \"g\", \"j\", \"k\", \"l\", \"s\", \"z\")\nvector03 <- c(\"jorge\", \"roy\", \"daniel\", \"cesar\", \"patin\", 254, 265)\nvector04 <- c(FALSE, FALSE, FALSE, TRUE, TRUE, TRUE, TRUE)\n\n\nAlgunas operaciones con vectores\n\n\nCode\n# indexar vectores\nvector01\nvector01[4]\n# evaluar la naturaleza del vector\na <- vector01[4]\nis.vector(a)\nis.numeric(a)\nis.integer(a)\n# operaciones con vectores\nlength(vector01)\n(vector01 * 2) + 500\nsum(vector01)\nsqrt(vector01 - 1)\nvector01 + (vector01 * 2)\n\n\n\n\n3.5.3 Matrix\nUna matriz es una estructura bidimensional. Las filas son horizontales y las columnas son verticales. Una matriz de 4 por 3 (4 x 3), por ejemplo, tiene 4 filas y 3 columnas. Las matrices se crean comúnmente usando tablas de datos numéricos como las de una hoja de cálculo de Excel o un archivo csv.\n\n\nCode\nvector01\n\n\n[1]  1  2  4  7 10 11 12 19 26\n\n\nCode\ndim(vector01)\n\n\nNULL\n\n\nDado que la variable es un vector, no tiene un atributo dim (entonces es simplemente NULL).\n¿Qué ocurre si le damos a vector01 un atributo dim?\n\n\nCode\ndim(vector01) <- c(3, 3)\nclass(vector01)\n\n\n[1] \"matrix\" \"array\" \n\n\nEl ejemplo que utilizamos hasta ahora tenía la intención de ilustrar la idea de que una matriz es simplemente un vector con un atributo de dimensión.\nUn método más directo para crear la misma matriz utiliza la función matrix.\n\n\nCode\nmatrix01 <- matrix(vector01, nrow = 3, ncol = 3, byrow = T)\n\n\n\n\nCode\narboles <- c(\"Tipuana tipu\", \"Myrsine andina\", \"Salix humboldtiana\")\nmatrix02 <- cbind(arboles, matrix01) # column bind o juntar por columna.\n\n\nEsto se llama coerción implícita porque no lo hemos pedido. Solo sucedió. Sin embargo, todavía se desea trabajar con diferentes tipos de datos.\n\n\nCode\nclass(matrix02)\n\n\n[1] \"matrix\" \"array\" \n\n\nCode\ndim(matrix02)\n\n\n[1] 3 4\n\n\nCode\nrownames(matrix02)\n\n\nNULL\n\n\nCode\ncolnames(matrix02)\n\n\n[1] \"arboles\" \"\"        \"\"        \"\"       \n\n\n\n\n3.5.4 Data Frame\nUn data frame es una estructura de datos bidimensional similar a una matriz, pero funciona de manera muy diferente. Si bien un data frame parece una tabla simple, de hecho es una lista de vectores de la misma longitud. Las matrices y los data frames parecen similares, sin embargo, la principal diferencia es que un data frame permite tipos de datos mixtos (por ejemplo, numérico, lógico, caracter). Esto les permite almacenar diferentes tipos de variables, lo cual es muy útil en el análisis estadístico. Por ejemplo, en un análisis de regresión. Las matrices se usan principalmente para almacenar datos numéricos, y se pueden usar para álgebra matricial.\nMatrices y Data Frames, ambos representan tipos de datos rectangulares, lo que significa que se usan para almacenar datos tabulares, con filas y columnas.\nLa principal diferencia, es que las matrices solo pueden contener una única clase de datos (al igual que los vectores), mientras que los dataframes pueden consistir de muchas clases diferentes de datos.\n\n\nCode\n# se crea un data frame (df)\ndf01 <- data.frame(arboles, matrix01)\nclass(df01)\n\n\n[1] \"data.frame\"\n\n\nCode\n# podemos cambiar el nombre a las variables (columnas)\ncolnames(df01) <- c(\"nombre_cientifico\", \"circunferencia\", \"diametro_copa\", \"altura\" )\n\n\n\n3.5.4.1 Conjunto de datos en R\nVarios conjuntos de datos tabulados o datasets se icluyen en la instalación de R (en el paquete datasets) y por defecto se ecuentran cargados para su uso. la funcion data() lista todos los datasets de R.\nTrabajemos con el dataset iris (Edgar Anderson’s Iris Data)\n\n\nCode\nstr(iris)\n# todas las observaciones de la columna 'Species'\niris[, \"Species\"]\n# Se utiliza el caracter ‘$’ para acceder a los campos o columnas.\niris$Species\n\n\nCuando queremos extraer datos del data frame según una condicion, esto se complica.\n\n\nCode\nhead(iris[iris$Species == \"setosa\", ])\n\n\nAsí mismo, si se desea obtener las observaciones donde el ancho del sépalo sea menor o igual a 3 y la especie sea “setosa”.\n\n\nCode\nhead(iris[iris[, \"Sepal.Width\"] <= 3 & iris[, \"Species\"] == \"setosa\", ])\n\n\n\n\n3.5.4.2 Subsetting\nLa función subset nos facilita filtrar datos cuando queremos que se cumplan ciertas condiciones.\n\n\nCode\nsubset(iris, Sepal.Width <= 3 & Species == \"setosa\")\n\n\n¿Pero es la mejor opción? ¿Cómo ordeno? ¿Cómo cambio de un formato “ancho” a un formato “largo” (o viceversa)? etc.\nLa tendencia en la comunidad R para el tratamiento de datos, comprende el uso de tidyverse.\n\n\n\n3.5.5 Listas\nA diferencia de un vector, una lista es una colección de elementos que pueden ser de diferente tipo. Los componentes de una lista son típicamente pares clave-valor (key-value). El siguiente ejemplo muestra cómo se puede almacenar un punto (con coordenas) en una lista.\n\n\nCode\n# Los elementos de la lista generalmente se acceden por nombre\ncoordenadas <- list(x = 10, y = 15)\ncoordenadas\npoint <- list(id = 123, coord = coordenadas, spatial.reference = \"WGS_84\")\npoint\npoint$id\n# También podemos acceder a sus elementos de la siguiente manera\npoint[1]\nclass(point[1])\n# Para obtener el valor del elemento de la lista, use corchetes dobles\npoint[[1]]\nclass(point[[1]])\n\n\nLa lista, en el ejemplo, tiene tres elementos de diferentes tipos de datos. id es numérico, coord es otra lista y spatial.reference es una cadena de caracteres. La lista coord contiene dos elementos numéricos, x e y. Generalmente, se accede a los elementos de la lista usando su nombre, en lugar de número. En particular, muchas estructuras de datos tienen elementos con nombre a los que se puede acceder utilizando los operadores $ o @."
  },
  {
    "objectID": "c02_intro_R.html#lectura-escritura-de-datos-.csv-.xlsx-.rdata-.rds",
    "href": "c02_intro_R.html#lectura-escritura-de-datos-.csv-.xlsx-.rdata-.rds",
    "title": "3  Primeros pasos en R",
    "section": "3.6 Lectura / escritura de datos (.csv, .xlsx, .RData, .rds)",
    "text": "3.6 Lectura / escritura de datos (.csv, .xlsx, .RData, .rds)\nEn la pestaña en Entorno (Environment) de RStudio podemos importar conjuntos de datos o datasets con el asistente de importación. No es recomendable cuando debemos importar varios archivos o si se van a leer archivos grandes. Para lo cual es más eficiente usar código.\n\n\n3.6.1 CSV\nSi conocemos la estructura de nuestros datos (por ejemplo, la primera fila es el título de las columnas o es un archivo separado por comas), Se pueden utilizar las funciones read.csv (librería base) o read_csv (librería readr, de tidyverse):\n\n\nCode\n# datos será un 'data frame'\ndata01 <- read.csv(file = 'data/file.csv')\nhead(data01)\n\n\n  Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n1          5.1         3.5          1.4         0.2  setosa\n2          4.9         3.0          1.4         0.2  setosa\n3          4.7         3.2          1.3         0.2  setosa\n4          4.6         3.1          1.5         0.2  setosa\n5          5.0         3.6          1.4         0.2  setosa\n6          5.4         3.9          1.7         0.4  setosa\n\n\nCode\n# datos será un 'tibble'\ndata01 <- readr::read_csv(file = 'data/file.csv')\n\n\nRows: 150 Columns: 5\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (1): Species\ndbl (4): Sepal.Length, Sepal.Width, Petal.Length, Petal.Width\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n\nCode\ndata01\n\n\n# A tibble: 150 × 5\n   Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n          <dbl>       <dbl>        <dbl>       <dbl> <chr>  \n 1          5.1         3.5          1.4         0.2 setosa \n 2          4.9         3            1.4         0.2 setosa \n 3          4.7         3.2          1.3         0.2 setosa \n 4          4.6         3.1          1.5         0.2 setosa \n 5          5           3.6          1.4         0.2 setosa \n 6          5.4         3.9          1.7         0.4 setosa \n 7          4.6         3.4          1.4         0.3 setosa \n 8          5           3.4          1.5         0.2 setosa \n 9          4.4         2.9          1.4         0.2 setosa \n10          4.9         3.1          1.5         0.1 setosa \n# … with 140 more rows\n\n\nEn otros casos, cuando \";\" es utilizado como el separador de campo y \",\" para el punto decimal, se utiliza una variante de estas funciones.\n\n\nCode\n# datos será un 'data frame'\ndata02 <- read.csv(file = 'data/file.csv', sep = ',', header = T)\n\n\nLa escritura de datos se realiza de la siguiente manera:\n\n\nCode\nreadr::write_csv(x = data02, file = \"data/csv_data.csv\")\n\n\n\n\n3.6.2 EXCEL\nEs posible leer datos en la forma .xls o .xlsx. Existen distintos paquetes que nos permiten hacerlo:\n\nEl paquete readxl contiene la función read_excel.\nEl paquete xlsx y la función read.xlsx\n\n\n\nCode\n# datos será un 'data frame'\ndata03 <- readxl::read_xls(path = \"data/file.xls\", sheet = 1)\ndata03 <- xlsx::read.xlsx(file = \"data/file.xls\", 1)\n\n\nLa escritura de datos se realiza de la siguiente manera:\n\n\nCode\nxlsx::write.xlsx(\n  data03, \"data/xlsx_data.xlsx\", sheetName = \"Sheet1\", \n  col.names = TRUE, row.names = TRUE, append = FALSE\n)\n\n\n\n\n3.6.3 RDS\nR proporciona dos formatos de archivo propios para almacenar datos, .RDS y .RData . Los archivos RDS pueden almacenar un solo objeto R y los archivos RData pueden almacenar varios objetos R.\nPuede abrir un archivo RDS con readRDS:\n\n\nCode\ndata04 <- readRDS(\"data/file.RDS\")\n\n\nLa escritura de datos se realiza de la siguiente manera:\n\n\nCode\nsaveRDS(data04, file = \"data/rds_data.RDS\")\n\n\n\n\n3.6.4 RDATA\nLa escritura de estos datos se realiza de la siguiente manera:\n\n\nCode\na <- 1\nb <- 2\nc <- 3\nsave(a, b, c, file = \"data/stuff.RData\")\n\n\nPuede abrir un archivo RData con load:\n\n\nCode\nload(\"data/stuff.RData\")"
  },
  {
    "objectID": "c03_intro_R2.html#control-de-flujo-condicionales",
    "href": "c03_intro_R2.html#control-de-flujo-condicionales",
    "title": "4  Control de Flujo y funciones",
    "section": "4.1 Control de Flujo Condicionales",
    "text": "4.1 Control de Flujo Condicionales\nLa toma de decisiones es una parte importante de la programación. Esto se puede lograr en la programación R usando la nomenclatura condicional if else.\n\n4.1.1 If\n\n\nCode\nif (expresion) {\n  declaracion\n}\n\n\n\nSi expresion es TRUE, la instrucción se ejecuta. Pero si es FALSO, no pasa nada.\nAquí, expresion puede ser un vector lógico o numérico, pero solo se tiene en cuenta el primer elemento.\nEn el caso del vector numérico, cero se toma como FALSO, el resto como VERDADERO.\n\n\n\n4.1.2 If…Else\n\n\nCode\nif (expresion) {\n    declaracion1\n  }else{\n    declaracion2\n}\n\n\nLa parte else es opcional y solo se evalúa si expresion es FALSE. Es importante tener en cuenta que else debe estar en la misma línea que las llaves de cierre de la instrucción if.\n\n\nCode\nx <- 0\nif (x < 0) {\n  print(\"Numero negativo\")\n}else if (x > 0) {\n  print(\"Numero positivo\")\n} else {\n  print(\"Cero\")\n}\n\n\n\n\nCode\ntemp = [15, 22, 30]\nsuelo= [\"seco\", \"humedo\", \"charcos\"]\nvaltemp = temp[0]\nvalsuelo= suelo[2]\nif 12<= valtemp < 22 and valsuelo ==\"seco\": \n    print(\"Cielo despejado\")\n    \nelif valtemp == 22 or valsuelo == \"humedo\":\n    print(\"lluvia leve\")\n    \nelif valtemp > 22 and valsuelo==\"charcos\":\n      print(\"lluvia severa\")\n    \nelse: print(\" Faltan datos\")\n\n\n\n\nCode\ntemp <- c(15, 22, 30)\nsuelo <- c(\"seco\", \"humedo\", \"charcos\")\nvaltemp <- temp[1]\nvalsuelo <- suelo[3]\nif (valtemp %in% 12:22 & valsuelo ==\"seco\") {\n  print(\"\\nCielo despejado\")\n} else if (valtemp == 22 | valsuelo == \"humedo\"){\n  print(\"\\nlluvia leve\")\n} else if (valtemp > 22 & valsuelo==\"charcos\"){\n  print(\"\\nlluvia severa\")\n} else {\n  print(\"\\nFaltan datos\")\n  }"
  },
  {
    "objectID": "c03_intro_R2.html#control-de-flujo-de-iteradores",
    "href": "c03_intro_R2.html#control-de-flujo-de-iteradores",
    "title": "4  Control de Flujo y funciones",
    "section": "4.2 Control de Flujo de Iteradores",
    "text": "4.2 Control de Flujo de Iteradores\nLos bucles son una de las estructuras fundamentales en la programación. Los bucles permiten iterar sobre cada elemento en una secuencia, uno a la vez, y hacer algo con esos elementos.\n\n4.2.1 FOR\nUn bucle for es muy valioso cuando necesitamos iterar sobre una lista de elementos o un rango de números. Loop se puede usar para iterar sobre una lista, marco de datos, vector, matriz o cualquier otro objeto. Los tirantes y el corchete son obligatorios.\n\n\nCode\nfor (valor in secuencia)\n  {\n    cuerpo\n  }\n\n\n\n\nCode\n# Creando un vector de frutas\nfrutas <- c('Apple', 'Orange', 'Passion fruit', 'Banana')\n# Declarando el bucle for\nfor ( i in frutas){ \n print(i)\n}\n\n\n[1] \"Apple\"\n[1] \"Orange\"\n[1] \"Passion fruit\"\n[1] \"Banana\"\n\n\n\n\n4.2.2 WHILE\nUn bucle es una declaración que continúa ejecutándose mientras se cumple una condición. La sintaxis para un ciclo while es la siguiente:\n\n\nCode\nwhile (condición)\n  {\n    cuerpo\n  }\n\n\n\n\nCode\n# creando la expresión con valor 1\ninicio <- 1\n# Creando el loop\nwhile (inicio <= 5){\n  # Ver donde estamos\n  cat('Este es el ciclo número ', inicio)\n  # Agregar 1 a la variable inicio despues de cada iteracion\n  inicio <- inicio + 1\n  print(inicio)\n}\n\n\nEste es el ciclo número  1[1] 2\nEste es el ciclo número  2[1] 3\nEste es el ciclo número  3[1] 4\nEste es el ciclo número  4[1] 5\nEste es el ciclo número  5[1] 6\n\n\nOtros iteradores\n\nrepeat\ndo-while (*otros leguajes)\n\nControl de flujo * break, next"
  },
  {
    "objectID": "c03_intro_R2.html#funciones",
    "href": "c03_intro_R2.html#funciones",
    "title": "4  Control de Flujo y funciones",
    "section": "4.3 Funciones",
    "text": "4.3 Funciones"
  },
  {
    "objectID": "c03_intro_R2.html#paquetes-y-librerías",
    "href": "c03_intro_R2.html#paquetes-y-librerías",
    "title": "4  Control de Flujo y funciones",
    "section": "4.4 Paquetes y librerías",
    "text": "4.4 Paquetes y librerías\nLos paquetes de R amplían la funcionalidad de R al proporcionar funciones, datos y documentación adicionales.Están escritos por una comunidad mundial de usuarios de R y pueden ser instalados desde la interfaz gráfica de RStudio\nSolo tienes que instalar el paquete una vez, si desea actualizar un paquete previamente instalado a una versión más nueva, puede ir a la ventana de Ficheros en Packages > Update y seleccionar los paquetes que desea actualizar.\n\nNo podrá utilizar las funciones, los objetos y los archivos de ayuda de un paquete hasta que lo cargue con library(). Una vez que haya instalado un paquete, puede cargarlo con la función library():\n\n\n4.4.1 Diferencias entre paquetes y librerías\nEn el caso de la función library(), en muchas ocasiones existe la confusión entre un paquete y una librería, y podemos encontrarnos con gente llamando “librerías” a los paquetes.\nUna cosa es la función library() usada para cargar un paquete, y que se refiere al lugar en dónde el paquete es localizado, habitualmente una carpeta en nuestro ordenador, y otra un paquete que es una colección de funciones y datos empaquetados de forma conveniente.\nDicho de otra manera, y en palabras de Hadley Wickham, científico de datos en RStudio, y creador de la gran mayoría de paquetes del ecosistema tidyverse:\n\nDe igual manera, para recordar la diferencia es ejecutar la función library() sin argumentos. Esto nos proporcionará una lista de paquetes instalados en diferentes librerías en nuestro ordenador.\n\n\nCode\n# Install packages\ninstall.packages(\"tidyverse\")\n# Load packages\nlibrary(tidyverse)\n# You can also use \"pacman\" package to install\n#  an loading other packages\nif (!require(\"pacman\")) {\n  install.packages(\"pacman\")\n}\npacman::p_load(\n  tidyverse, formatR, knitr, rmdformats, pander, labelled, readxl, magrittr, kableExtra,\n  Lahman, datos\n)"
  },
  {
    "objectID": "c01_introduccion.html#interfaz-de-desarrollo-integrado-ide-y-editor-de-texto",
    "href": "c01_introduccion.html#interfaz-de-desarrollo-integrado-ide-y-editor-de-texto",
    "title": "2  Introducción a los lenguajes de programación",
    "section": "2.2 Interfaz de Desarrollo Integrado (IDE) y editor de texto",
    "text": "2.2 Interfaz de Desarrollo Integrado (IDE) y editor de texto\n\n\n\nIDEs y editores de texto"
  },
  {
    "objectID": "c02_intro_R.html#tipos-de-datos-en-r",
    "href": "c02_intro_R.html#tipos-de-datos-en-r",
    "title": "3  Primeros pasos en R",
    "section": "3.2 Tipos de datos en R",
    "text": "3.2 Tipos de datos en R\nR es capaz de manejar una variedad de tipos de datos, que se almacenan en diferentes estructuras como se puede observar en la siguiente tabla:\n\n\n\n\n\n\n\n\nTipos de Datos\nInformación\nDefinición\n\n\n\n\nNumeric\nDatos contenidos en el conjuntos de los números reales\nnum <- 3.14\n\n\nInteger\nDatos contenidos en el conjuntos de los números enteros\nint <- 3L\n\n\nCharacter\nDatos que soportan cadenas de caracteres\nchr <- \"hello world\"\n\n\nComplex\nDatos que soportan números complejos\ncomp <- 3+2i\n\n\nLogical\nDatos que sólo soportan valores lógicos de verdadero (T) o falso (F)\na <- 1; b <- 2; a < b\n\n\nFactor\nEste no es estrictamente un tipo de dato, pero vale la pena describirlo aquí. Una variable factor es una variable categórica. Los vectores de caracteres a menudo se almacenan como factores para explotar funciones para tratar datos categóricos. Por ejemplo, en análisis de regresión\nAplique as.factor() a un vector de caracteres o numéricos"
  },
  {
    "objectID": "c02_intro_R.html#ambiente-de-trabajo-en-rstudio",
    "href": "c02_intro_R.html#ambiente-de-trabajo-en-rstudio",
    "title": "3  Primeros pasos en R",
    "section": "3.1 Ambiente de trabajo en RStudio",
    "text": "3.1 Ambiente de trabajo en RStudio\nLa interfaz gráfica de RStudio nos permite acceder a scripts, datos, encontrar ayuda y previsualizar gráficos y resultados."
  },
  {
    "objectID": "c02_intro_R.html#estructuras-de-datos",
    "href": "c02_intro_R.html#estructuras-de-datos",
    "title": "3  Primeros pasos en R",
    "section": "3.3 Estructuras de datos",
    "text": "3.3 Estructuras de datos\n\n\n\n\n\n\n\n\nObjetos\nTipos\n¿Soporta varios tipos de datos en el mismo objeto?\n\n\n\n\nVector\nNumérico, carácter, complejo o lógico\nNo\n\n\nFactor\nNumérico o lógico\nNo\n\n\nArreglo\nNumérico, carácter, complejo o lógico\nNo\n\n\nMatriz\nNumérico, carácter, complejo o lógico\nNo\n\n\nData frame\nNumérico, carácter, complejo o lógico\nSí\n\n\nts\nNumérico, carácter, complejo o lógico\nSí\n\n\nLista\nNumérico, carácter, complejo, lógico, función, expresión, …\nSí"
  },
  {
    "objectID": "c02_intro_R.html#espacio-y-directorio-de-trabajo",
    "href": "c02_intro_R.html#espacio-y-directorio-de-trabajo",
    "title": "3  Primeros pasos en R",
    "section": "3.6 Espacio y directorio de trabajo",
    "text": "3.6 Espacio y directorio de trabajo\n\n\n\n\n\n\n\nFunción\nAcción\n\n\n\n\ngetwd()\nMuestra el wd: working directory\n\n\nsetwd(\"midirectorio\")\nAjusta el wd al especificado\n\n\nls()  o dir()\nLista lo que hay en el wd\n\n\nhistory()\nMuestra los últimos comandos ejecutados\n\n\nsavehistory()\nGuarda el historial de comandos, por defecto en .Rhistory\n\n\nloadhistory()\nCarga el historial de comandos\n\n\nsave.image(\"mywspace.R\")\nGuarda los objetos del workspace, por defecto en .Rdata\n\n\nload(\"mywspace.R\")\nCarga el workspace mywspace.R\n\n\n\n\n3.6.1 Vector\n\nEs el elemento más básico en R.\nContiene elementos de la misma clase (son atómicos).\nSe crea con la función c(), que significa ‘concatenar’ o ‘combinar’.\n\n\n\nCode\nvector01 <- c(1, 2, 4, 7, 10, 11, 12, 19, 26)\nvector02 <- c(\"a\", \"b\", \"d\", \"g\", \"j\", \"k\", \"l\", \"s\", \"z\")\nvector03 <- c(\"jorge\", \"roy\", \"daniel\", \"cesar\", \"patin\", 254, 265)\nvector04 <- c(FALSE, FALSE, FALSE, TRUE, TRUE, TRUE, TRUE)\n\n\nAlgunas operaciones con vectores\n\n\nCode\n# indexar vectores\nvector01\nvector01[4]\n# evaluar la naturaleza del vector\na <- vector01[4]\nis.vector(a)\nis.numeric(a)\nis.integer(a)\n# operaciones con vectores\nlength(vector01)\n(vector01 * 2) + 500\nsum(vector01)\nsqrt(vector01 - 1)\nvector01 + (vector01 * 2)\n\n\n\n\n3.6.2 Factor\nEn R, los factores se usan para trabajar con variables categóricas, es decir, variables que tienen un conjunto fijo y conocido de valores posibles. También son útiles cuando quieres mostrar vectores de caracteres en un orden no alfabético.\nImagina que tienes una variable que registra meses:\n\n\nCode\nvect01 <- c(\"Dec\", \"Apr\", \"Jan\", \"Mar\", \"Jan\", \"Mar\")\n\n\nUsar una cadena de caracteres (o string, en inglés) para guardar esta variable tiene dos problemas:\n\nSolo hay doce meses posibles y no hay nada que te resguarde de errores de tipeo:\n\n\n\nCode\nvect02 <- c(\"Dec\", \"Apr\", \"Jam\", \"Mar\", \"Jan\", \"Mar\")\n\n\n\nNo se ordena de una forma útil:\n\n\n\nCode\nsort(vect02)\n\n\n[1] \"Apr\" \"Dec\" \"Jam\" \"Jan\" \"Mar\" \"Mar\"\n\n\nPuedes solucionar ambos problemas con un factor. Para crearlo, debes empezar definiendo una lista con los niveles válidos:\n\n\nCode\nmonth_levels <- month.abb\n\n\nAhora puedes crear un factor:\n\n\nCode\nfactor01 <- factor(vect01, levels = month_levels)\nsort(factor01)\n\n\n[1] Jan Jan Mar Mar Apr Dec\nLevels: Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec\n\n\nCualquier valor no fijado en el conjunto será convertido a NA de forma silenciosa:\n\n\nCode\nfactor02 <- factor(vect02, levels = month_levels)\n\n\nSi quieres una advertencia, puedes usar readr::parse_factor() (segmentar un factor, en inglés):\n\n\nCode\nreadr::parse_factor(vect02, levels = month_levels)\n\n\nWarning: 1 parsing failure.\nrow col           expected actual\n  3  -- value in level set    Jam\n\n\n[1] Dec  Apr  <NA> Mar  Jan  Mar \nattr(,\"problems\")\n# A tibble: 1 × 4\n    row   col expected           actual\n  <int> <int> <chr>              <chr> \n1     3    NA value in level set Jam   \nLevels: Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec\n\n\nSi omites los niveles, se van a definir a partir de los datos en orden alfabético:\n\n\nCode\n  factor(vect01)\n\n\n[1] Dec Apr Jan Mar Jan Mar\nLevels: Apr Dec Jan Mar\n\n\nA veces es preferible que el orden de los niveles se corresponda con su primera aparición en los datos. Puedes hacer esto cuando creas el factor, al definir los niveles con unique(x) o después con fct_inorder().\n\n\nCode\nfactor(vect01, levels = unique(vect01))\n\n\n[1] Dec Apr Jan Mar Jan Mar\nLevels: Dec Apr Jan Mar\n\n\nCode\nforcats::fct_inorder(factor(vect01))\n\n\n[1] Dec Apr Jan Mar Jan Mar\nLevels: Dec Apr Jan Mar\n\n\n\n\n3.6.3 Matrix\nUna matriz es una estructura bidimensional. Las filas son horizontales y las columnas son verticales. Una matriz de 4 por 3 (4 x 3), por ejemplo, tiene 4 filas y 3 columnas. Las matrices se crean comúnmente usando tablas de datos numéricos como las de una hoja de cálculo de Excel o un archivo csv.\n\n\nCode\nvector01\n\n\n[1]  1  2  4  7 10 11 12 19 26\n\n\nCode\ndim(vector01)\n\n\nNULL\n\n\nDado que la variable es un vector, no tiene un atributo dim (entonces es simplemente NULL).\n¿Qué ocurre si le damos a vector01 un atributo dim?\n\n\nCode\ndim(vector01) <- c(3, 3)\nclass(vector01)\n\n\n[1] \"matrix\" \"array\" \n\n\nEl ejemplo que utilizamos hasta ahora tenía la intención de ilustrar la idea de que una matriz es simplemente un vector con un atributo de dimensión.\nUn método más directo para crear la misma matriz utiliza la función matrix.\n\n\nCode\nmatrix01 <- matrix(vector01, nrow = 3, ncol = 3, byrow = T)\n\n\n\n\nCode\narboles <- c(\"Tipuana tipu\", \"Myrsine andina\", \"Salix humboldtiana\")\nmatrix02 <- cbind(arboles, matrix01) # column bind o juntar por columna.\n\n\nEsto se llama coerción implícita porque no lo hemos pedido. Solo sucedió. Sin embargo, todavía se desea trabajar con diferentes tipos de datos.\n\n\nCode\nclass(matrix02)\n\n\n[1] \"matrix\" \"array\" \n\n\nCode\ndim(matrix02)\n\n\n[1] 3 4\n\n\nCode\nrownames(matrix02)\n\n\nNULL\n\n\nCode\ncolnames(matrix02)\n\n\n[1] \"arboles\" \"\"        \"\"        \"\"       \n\n\n\n\n3.6.4 Data Frame\nUn data frame es una estructura de datos bidimensional similar a una matriz, pero funciona de manera muy diferente. Si bien un data frame parece una tabla simple, de hecho es una lista de vectores de la misma longitud. Para los nuevos usuarios de R, las matrices y los data frames parecen similares. La principal diferencia es que un data frame permite tipos de datos mixtos (por ejemplo, numérico, lógico, caracter). Esto les permite almacenar diferentes tipos de variables, lo cual es muy útil en el análisis estadístico. Por ejemplo, en un análisis de regresión. Las matrices se usan principalmente para almacenar datos numéricos, y se pueden usar para álgebra matricial.\nMatrices y Data Frames, ambos representan tipos de datos rectangulares, lo que significa que se usan para almacenar datos tabulares, con filas y columnas.\nLa principal diferencia, es que las matrices solo pueden contener una única clase de datos (al igual que los vectores), mientras que los dataframes pueden consistir de muchas clases diferentes de datos.\n\n\nCode\n# se crea un data frame (df)\ndf01 <- data.frame(arboles, matrix01)\nclass(df01)\n\n\n[1] \"data.frame\"\n\n\nCode\n# podemos cambiar el nombre a las variables (columnas)\ncolnames(df01) <- c(\"nombre_cientifico\", \"circunferencia\", \"diametro_copa\", \"altura\" )\n\n\n\n3.6.4.1 Conjunto de datos en R\nVarios conjuntos de datos tabulados o datasets se icluyen en la instalación de R (en el paquete datasets) y por defecto se ecuentran cargados para su uso. la funcion data() lista todos los datasets de R.\nTrabajemos con el dataset iris (Edgar Anderson’s Iris Data)\n\n\nCode\nstr(iris)\n# todas las observaciones de la columna 'Species'\niris[, \"Species\"]\n# Se utiliza el caracter ‘$’ para acceder a los campos o columnas.\niris$Species\n\n\nCuando queremos extraer datos del data frame según una condicion, esto se complica.\n\n\nCode\nhead(iris[iris$Species == \"setosa\", ])\n\n\nAsí mismo, si se desea obtener las observaciones donde el ancho del sépalo sea menor o igual a 3 y la especie sea “setosa”.\n\n\nCode\nhead(iris[iris[, \"Sepal.Width\"] <= 3 & iris[, \"Species\"] == \"setosa\", ])\n\n\n\n\n3.6.4.2 Subsetting\nLa función subset nos facilita filtrar datos cuando queremos que se cumplan ciertas condiciones.\n\n\nCode\nsubset(iris, Sepal.Width <= 3 & Species == \"setosa\")\n\n\n¿Pero es la mejor opción? ¿Cómo ordeno? ¿Cómo cambio de un formato “ancho” a un formato “largo” (o viceversa)? etc.\nLa tendencia en la comunidad R para el tratamiento de datos, comprende el uso de tidyverse.\n\n\n\n3.6.5 Listas\nA diferencia de un vector, una lista es una colección de elementos que pueden ser de diferente tipo. Los componentes de una lista son típicamente pares clave-valor (key-value). El siguiente ejemplo muestra cómo se puede almacenar un punto (con coordenas) en una lista.\n\n\nCode\n# Los elementos de la lista generalmente se acceden por nombre\ncoordenadas <- list(x = 10, y = 15)\ncoordenadas\npoint <- list(id = 123, coord = coordenadas, spatial.reference = \"WGS_84\")\npoint\npoint$id\n# También podemos acceder a sus elementos de la siguiente manera\npoint[1]\nclass(point[1])\n# Para obtener el valor del elemento de la lista, use corchetes dobles\npoint[[1]]\nclass(point[[1]])\n\n\nLa lista, en el ejemplo, tiene tres elementos de diferentes tipos de datos. id es numérico, coord es otra lista y spatial.reference es una cadena de caracteres. La lista coord contiene dos elementos numéricos, x e y. Generalmente, se accede a los elementos de la lista usando su nombre, en lugar de número. En particular, muchas estructuras de datos tienen elementos con nombre a los que se puede acceder utilizando los operadores $ o @."
  }
]