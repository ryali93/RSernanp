[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Taller de programación R - SERNANP",
    "section": "",
    "text": "1 Presentación\nEl SERNANP brinda el servicio de mantener áreas protegidas en buen estado de conservación para asegurar la provisión de servicios ambientales que generen bienestar a poblaciones. Uno de los pilares para alcanzar dicha eficiencia es gestionar la información espacial generada en el interior de las áreas, así como información externa de aliados estratégicos y demás instiuciones que contribuyen al desarrollo del medio ambiente.\nEste taller tiene el objetivo de servir como herramienta para la gestión de información y pueda ser insumo para la toma de decisiones que lleven a implementar acciones con el fin de contribuir con el mantenimiento del buen estado de conservación de las ANP."
  },
  {
    "objectID": "c01_introduccion.html#lenguajes-de-programación",
    "href": "c01_introduccion.html#lenguajes-de-programación",
    "title": "2  Introducción a los lenguajes de programación",
    "section": "2.1 Lenguajes de programación",
    "text": "2.1 Lenguajes de programación\nUn lenguaje de programación es una forma de comunicarnos con una computadora e indicarle qué queremos hacer. En otras palabras, nos permitirá darle instrucciones y reglas que permiten crear herramientas, programas, realizar análisis o tareas específicas.\nExisten distintos tipos de lenguaje, según la conexión entre el software y hardware podemos diferenciarlos en lenguajes bajo nivel y de alto nivel. La diferencia se encuentra en lo cerca o lejos que estemos del hardware de nuestro equipo.\nAdemás, podemos diferenciarlos según el propósito o el modo de uso, aquellos que están orientados al desarrollo y aquellos que están orientados al análisis. Los lenguajes orientados al desarrollo se utilizan para crear aplicaciones y programas, mientras que los lenguajes orientados al análisis se utilizan para procesar y analizar datos.\n\n\n\nLenguajes de programación"
  },
  {
    "objectID": "c01_introduccion.html#interfaz-de-desarrollo-integrado-ide-y-editor-de-texto",
    "href": "c01_introduccion.html#interfaz-de-desarrollo-integrado-ide-y-editor-de-texto",
    "title": "2  Introducción a los lenguajes de programación",
    "section": "2.2 Interfaz de Desarrollo Integrado (IDE) y editor de texto",
    "text": "2.2 Interfaz de Desarrollo Integrado (IDE) y editor de texto\n\n\n\nIDEs y editores de texto"
  },
  {
    "objectID": "c01_introduccion.html#qué-es-r",
    "href": "c01_introduccion.html#qué-es-r",
    "title": "2  Introducción a los lenguajes de programación",
    "section": "2.3 ¿Qué es R?",
    "text": "2.3 ¿Qué es R?\nR es un lenguaje de programación y entorno computacional dedicado a la estadística que proporciona un amplio abanico de herramientas estadísticas (modelos lineales y no lineales, tests estadísticos, análisis de series temporales, algoritmos de clasificación y agrupamiento, etc.)\nPermite definir funciones propias. De hecho, gran parte de las funciones de R están escritas en el mismo R, aunque para algoritmos computacionalmente exigentes es posible desarrollar bibliotecas en C, C++ o Fortran que se cargan dinámicamente.\nR puede integrarse con distintas bases de datos y existen bibliotecas que facilitan su utilización desde lenguajes de programación interpretados como Python (PythonInR), hereda de S su orientación a objetos.\nOtra de las características de R es su capacidad gráfica, que permite generar gráficos con alta calidad (ggplot). R posee su propio formato para la documentación basado en LaTeX."
  },
  {
    "objectID": "c01_introduccion.html#qué-es-rstudio",
    "href": "c01_introduccion.html#qué-es-rstudio",
    "title": "2  Introducción a los lenguajes de programación",
    "section": "2.4 ¿Qué es RStudio?",
    "text": "2.4 ¿Qué es RStudio?\nRStudio es un editor para scripts disponible para usuarios de R en todos los sistemas operativos. Es considerado como un entorno de desarrollo integrado (GUI)que combina un interfaz muy intuitiva con herramientas de código muy potentes que permiten sacar el máximo provecho a R.\nLa ventaja de este editor es que ofrece una serie de opciones no existentes en R, entre otras, por ejemplo, comprobar rápidamente que ningún paréntesis queda sin cerrarse o marcar, copiar y pegar columnas.\nPero además nos da un listado de las variables y nos da una descripción de los bancos de datos que hemos introducido. También tiene una lista de los paquetes instalados y los gráficos realizados."
  },
  {
    "objectID": "c01_introduccion.html#qué-otros-ides-existen-para-r",
    "href": "c01_introduccion.html#qué-otros-ides-existen-para-r",
    "title": "2  Introducción a los lenguajes de programación",
    "section": "2.5 ¿Qué otros IDE’s existen para R?",
    "text": "2.5 ¿Qué otros IDE’s existen para R?\n\nTinn-R\nRKward\nRcommander\nJupyter notebook\nVisual studio code\nPycharm\nEclipse"
  },
  {
    "objectID": "c01_introduccion.html#instalación-de-r-rstudio-y-rtools",
    "href": "c01_introduccion.html#instalación-de-r-rstudio-y-rtools",
    "title": "2  Introducción a los lenguajes de programación",
    "section": "2.6 Instalación de R, RStudio y RTools",
    "text": "2.6 Instalación de R, RStudio y RTools\n\n2.6.1 R y RStudio\nPrimero deberá descargar e instalar R y luego RStudio.\nInstalación de R\nPara instalar R hay que bajar un fichero ejecutable de la página web del proyecto R: http://www.r-project.org/. Actualmente (Marzo 2023), la versión más reciente de R para el entorno Windows es la 4.2.3 y el ejecutable de tamaño aproximadamente 77Mb tiene el nombre R-4.2.3-win.exe.\nInstalación de RStudio\nPara instalar RStudio nos dirigimos al enlace http://www.rstudio.org/,la versión en pruebas es gratuita.Una vez bajado este ejecutable, hay que ejecutarlo y seguir las instrucciones del programa de instalación.\n\n\n2.6.2 RTools\nEs un paquete de herramientas para construir paquetes de R. Esto es lo que desea para construir sus propios paquetes en Windows, o para construir R por sí mismo. A partir de R 4.3.0 (2023), R para Windows usa un paquete de cadena de herramientas llamado rtools43.\nEsta versión de Rtools incluye gcc 8.3.0 e introduce un nuevo sistema de compilación basado en msys2`, que facilita la compilación y el mantenimiento de R, así como las bibliotecas del sistema que necesitan los paquetes de R en Windows. Las compilaciones recientes de rtools43 también contienen una cadena de herramientas adicional gcc-10 ucrt para probar paquetes de R y bibliotecas del sistema con las compilaciones ucrt experimentales de R-devel."
  },
  {
    "objectID": "c01_introduccion.html#tipos-de-lenguajes-de-programación",
    "href": "c01_introduccion.html#tipos-de-lenguajes-de-programación",
    "title": "2  Introducción a los lenguajes de programación",
    "section": "2.7 Tipos de lenguajes de programación",
    "text": "2.7 Tipos de lenguajes de programación\n\n2.7.1 Lenguaje compilado\nSon aquellos lenguajes de alto nivel que como su nombre lo sugiere, requieren de un compilador (programa que traduce un lenguaje de alto nivel en código máquina o lenguaje máquina) para traducirlo y crear la parte ejecutable.\n\nC++\nGo\n\n\n\n2.7.2 Lenguaje interpretado\nSon aquellos lenguajes de programación también de alto nivel en donde el código fuente debe ser traducido a un lenguaje que la máquina entienda y pueda realizar, no crean un archivo externo.\n\nRuby\nJavascript\nPython\nR\n\nLos lenguajes de alto nivel permiten escribir instrucciones en un idioma muy parecido al inglés así como hacer uso de notaciones matemáticas comunes.\n\n\n2.7.3 Lenguaje intermedio\nLos lenguajes intermedios son compilados hacia programas intermedios y luego interpretados, esto permite que pueda ser ejecutado desde cualquier sistema operativo sin necesidad de crear ejecutables.\n\nJava\nC#"
  },
  {
    "objectID": "c01_introduccion.html#paradigmas-de-programación",
    "href": "c01_introduccion.html#paradigmas-de-programación",
    "title": "2  Introducción a los lenguajes de programación",
    "section": "2.8 Paradigmas de programación",
    "text": "2.8 Paradigmas de programación\nUn paradigma de programación es una manera o estilo de programación de software. Se trata de un conjunto de métodos sistemáticos aplicables en todos los niveles del diseño de programas para resolver problemas computacionales.\n\n2.8.1 Programación Orientado a Objetos\nSe construyen modelos de objetos que representan elementos (objetos) del problema a resolver, que tienen características y funciones. Permite separar los diferentes componentes de un programa, simplificando así su creación, depuración y posteriores mejoras. La programación orientada a objetos disminuye los errores y promociona la reutilización del código. Es una manera especial de programar, que se acerca de alguna manera a cómo expresaríamos las cosas en la vida real.\n\n\n2.8.2 Programación Funcional\nLa programación funcional es un paradigma declarativo. Nos enfocaremos en “qué” estamos haciendo y no en “cómo” se está haciendo que sería el enfoque imperativo. Esto quiere decir que se expresa nuestra lógica sin describir controles de flujo, ni ciclos ni condicionales."
  },
  {
    "objectID": "c02_intro_R.html#ambiente-de-trabajo-en-rstudio",
    "href": "c02_intro_R.html#ambiente-de-trabajo-en-rstudio",
    "title": "3  Primeros pasos en R",
    "section": "3.1 Ambiente de trabajo en RStudio",
    "text": "3.1 Ambiente de trabajo en RStudio\nLa interfaz gráfica de RStudio nos permite acceder a scripts, datos, encontrar ayuda y previsualizar gráficos y resultados."
  },
  {
    "objectID": "c02_intro_R.html#tipos-de-datos-en-r",
    "href": "c02_intro_R.html#tipos-de-datos-en-r",
    "title": "3  Primeros pasos en R",
    "section": "3.2 Tipos de datos en R",
    "text": "3.2 Tipos de datos en R\nR es capaz de manejar una variedad de tipos de datos, que se almacenan en diferentes estructuras como se puede observar en la siguiente tabla:\n\n\n\n\n\n\n\n\nTipos de Datos\nInformación\nDefinición\n\n\n\n\nNumeric\nDatos contenidos en el conjuntos de los números reales\nnum <- 3.14\n\n\nInteger\nDatos contenidos en el conjuntos de los números enteros\nint <- 3L\n\n\nCharacter\nDatos que soportan cadenas de caracteres\nchr <- \"hello world\"\n\n\nComplex\nDatos que soportan números complejos\ncomp <- 3+2i\n\n\nLogical\nDatos que sólo soportan valores lógicos de verdadero (T) o falso (F)\na <- 1; b <- 2; a < b\n\n\nFactor\nEste no es estrictamente un tipo de dato, pero vale la pena describirlo aquí. Una variable factor es una variable categórica. Los vectores de caracteres a menudo se almacenan como factores para explotar funciones para tratar datos categóricos. Por ejemplo, en análisis de regresión\nAplique as.factor() a un vector de caracteres o numéricos"
  },
  {
    "objectID": "c02_intro_R.html#estructuras-de-datos",
    "href": "c02_intro_R.html#estructuras-de-datos",
    "title": "3  Primeros pasos en R",
    "section": "3.3 Estructuras de datos",
    "text": "3.3 Estructuras de datos\n\n\n\n\n\n\n\n\nObjetos\nTipos\n¿Soporta varios tipos de datos en el mismo objeto?\n\n\n\n\nVector\nNumérico, carácter, complejo o lógico\nNo\n\n\nFactor\nNumérico o lógico\nNo\n\n\nArreglo\nNumérico, carácter, complejo o lógico\nNo\n\n\nMatriz\nNumérico, carácter, complejo o lógico\nNo\n\n\nData frame\nNumérico, carácter, complejo o lógico\nSí\n\n\nts\nNumérico, carácter, complejo o lógico\nSí\n\n\nLista\nNumérico, carácter, complejo, lógico, función, expresión, …\nSí"
  },
  {
    "objectID": "c02_intro_R.html#comience-a-codificar",
    "href": "c02_intro_R.html#comience-a-codificar",
    "title": "3  Primeros pasos en R",
    "section": "3.4 Comience a codificar",
    "text": "3.4 Comience a codificar\nComenzamos a codificar imprimiendo Hello worldy posteriormente asignando valores a un objeto\n\n\nCode\nprint(\"Hello world\")\n\n\n\n3.4.1 Asignación de objetos\n\n\nCode\nobj <- c(5, 2, 6, 58, 456, 56, 5)\nc(5, 2, 6, 58, 456, 56, 5) -> obj"
  },
  {
    "objectID": "c02_intro_R.html#conceptos-básicos-de-r",
    "href": "c02_intro_R.html#conceptos-básicos-de-r",
    "title": "3  Primeros pasos en R",
    "section": "3.5 Conceptos Básicos de R",
    "text": "3.5 Conceptos Básicos de R\n\n3.5.1 Espacio y directorio de trabajo\n\n\n\n\n\n\n\nFunción\nAcción\n\n\n\n\ngetwd()\nMuestra el wd: working directory\n\n\nsetwd(\"midirectorio\")\nAjusta el wd al especificado\n\n\nls()  o dir()\nLista lo que hay en el wd\n\n\nhistory()\nMuestra los últimos comandos ejecutados\n\n\nsavehistory()\nGuarda el historial de comandos, por defecto en .Rhistory\n\n\nloadhistory()\nCarga el historial de comandos\n\n\nsave.image(\"mywspace.R\")\nGuarda los objetos del workspace, por defecto en .Rdata\n\n\nload(\"mywspace.R\")\nCarga el workspace mywspace.R\n\n\n\n\n\n3.5.2 Vector\n\nEs el elemento más básico en R.\nContiene elementos de la misma clase (son atómicos).\nSe crea con la función c(), que significa ‘concatenar’ o ‘combinar’.\n\n\n\nCode\nvector01 <- c(1, 2, 4, 7, 10, 11, 12, 19, 26)\nvector02 <- c(\"a\", \"b\", \"d\", \"g\", \"j\", \"k\", \"l\", \"s\", \"z\")\nvector03 <- c(\"jorge\", \"roy\", \"daniel\", \"cesar\", \"patin\", 254, 265)\nvector04 <- c(FALSE, FALSE, FALSE, TRUE, TRUE, TRUE, TRUE)\n\n\nAlgunas operaciones con vectores\n\n\nCode\n# indexar vectores\nvector01\nvector01[4]\n# evaluar la naturaleza del vector\na <- vector01[4]\nis.vector(a)\nis.numeric(a)\nis.integer(a)\n# operaciones con vectores\nlength(vector01)\n(vector01 * 2) + 500\nsum(vector01)\nsqrt(vector01 - 1)\nvector01 + (vector01 * 2)\n\n\n\n\n3.5.3 Matrix\nUna matriz es una estructura bidimensional. Las filas son horizontales y las columnas son verticales. Una matriz de 4 por 3 (4 x 3), por ejemplo, tiene 4 filas y 3 columnas. Las matrices se crean comúnmente usando tablas de datos numéricos como las de una hoja de cálculo de Excel o un archivo csv.\n\n\nCode\nvector01\n\n\n[1]  1  2  4  7 10 11 12 19 26\n\n\nCode\ndim(vector01)\n\n\nNULL\n\n\nDado que la variable es un vector, no tiene un atributo dim (entonces es simplemente NULL).\n¿Qué ocurre si le damos a vector01 un atributo dim?\n\n\nCode\ndim(vector01) <- c(3, 3)\nclass(vector01)\n\n\n[1] \"matrix\" \"array\" \n\n\nEl ejemplo que utilizamos hasta ahora tenía la intención de ilustrar la idea de que una matriz es simplemente un vector con un atributo de dimensión.\nUn método más directo para crear la misma matriz utiliza la función matrix.\n\n\nCode\nmatrix01 <- matrix(vector01, nrow = 3, ncol = 3, byrow = T)\n\n\n\n\nCode\narboles <- c(\"Tipuana tipu\", \"Myrsine andina\", \"Salix humboldtiana\")\nmatrix02 <- cbind(arboles, matrix01) # column bind o juntar por columna.\n\n\nEsto se llama coerción implícita porque no lo hemos pedido. Solo sucedió. Sin embargo, todavía se desea trabajar con diferentes tipos de datos.\n\n\nCode\nclass(matrix02)\n\n\n[1] \"matrix\" \"array\" \n\n\nCode\ndim(matrix02)\n\n\n[1] 3 4\n\n\nCode\nrownames(matrix02)\n\n\nNULL\n\n\nCode\ncolnames(matrix02)\n\n\n[1] \"arboles\" \"\"        \"\"        \"\"       \n\n\n\n\n3.5.4 Data Frame\nUn data frame es una estructura de datos bidimensional similar a una matriz, pero funciona de manera muy diferente. Si bien un data frame parece una tabla simple, de hecho es una lista de vectores de la misma longitud. Las matrices y los data frames parecen similares, sin embargo, la principal diferencia es que un data frame permite tipos de datos mixtos (por ejemplo, numérico, lógico, caracter). Esto les permite almacenar diferentes tipos de variables, lo cual es muy útil en el análisis estadístico. Por ejemplo, en un análisis de regresión. Las matrices se usan principalmente para almacenar datos numéricos, y se pueden usar para álgebra matricial.\nMatrices y Data Frames, ambos representan tipos de datos rectangulares, lo que significa que se usan para almacenar datos tabulares, con filas y columnas.\nLa principal diferencia, es que las matrices solo pueden contener una única clase de datos (al igual que los vectores), mientras que los dataframes pueden consistir de muchas clases diferentes de datos.\n\n\nCode\n# se crea un data frame (df)\ndf01 <- data.frame(arboles, matrix01)\nclass(df01)\n\n\n[1] \"data.frame\"\n\n\nCode\n# podemos cambiar el nombre a las variables (columnas)\ncolnames(df01) <- c(\"nombre_cientifico\", \"circunferencia\", \"diametro_copa\", \"altura\" )\n\n\n\n3.5.4.1 Conjunto de datos en R\nVarios conjuntos de datos tabulados o datasets se icluyen en la instalación de R (en el paquete datasets) y por defecto se ecuentran cargados para su uso. la funcion data() lista todos los datasets de R.\nTrabajemos con el dataset iris (Edgar Anderson’s Iris Data)\n\n\nCode\nstr(iris)\n# todas las observaciones de la columna 'Species'\niris[, \"Species\"]\n# Se utiliza el caracter ‘$’ para acceder a los campos o columnas.\niris$Species\n\n\nCuando queremos extraer datos del data frame según una condicion, esto se complica.\n\n\nCode\nhead(iris[iris$Species == \"setosa\", ])\n\n\nAsí mismo, si se desea obtener las observaciones donde el ancho del sépalo sea menor o igual a 3 y la especie sea “setosa”.\n\n\nCode\nhead(iris[iris[, \"Sepal.Width\"] <= 3 & iris[, \"Species\"] == \"setosa\", ])\n\n\n\n\n3.5.4.2 Subsetting\nLa función subset nos facilita filtrar datos cuando queremos que se cumplan ciertas condiciones.\n\n\nCode\nsubset(iris, Sepal.Width <= 3 & Species == \"setosa\")\n\n\n¿Pero es la mejor opción? ¿Cómo ordeno? ¿Cómo cambio de un formato “ancho” a un formato “largo” (o viceversa)? etc.\nLa tendencia en la comunidad R para el tratamiento de datos, comprende el uso de tidyverse.\n\n\n\n3.5.5 Listas\nA diferencia de un vector, una lista es una colección de elementos que pueden ser de diferente tipo. Los componentes de una lista son típicamente pares clave-valor (key-value). El siguiente ejemplo muestra cómo se puede almacenar un punto (con coordenas) en una lista.\n\n\nCode\n# Los elementos de la lista generalmente se acceden por nombre\ncoordenadas <- list(x = 10, y = 15)\ncoordenadas\npoint <- list(id = 123, coord = coordenadas, spatial.reference = \"WGS_84\")\npoint\npoint$id\n# También podemos acceder a sus elementos de la siguiente manera\npoint[1]\nclass(point[1])\n# Para obtener el valor del elemento de la lista, use corchetes dobles\npoint[[1]]\nclass(point[[1]])\n\n\nLa lista, en el ejemplo, tiene tres elementos de diferentes tipos de datos. id es numérico, coord es otra lista y spatial.reference es una cadena de caracteres. La lista coord contiene dos elementos numéricos, x e y. Generalmente, se accede a los elementos de la lista usando su nombre, en lugar de número. En particular, muchas estructuras de datos tienen elementos con nombre a los que se puede acceder utilizando los operadores $ o @."
  },
  {
    "objectID": "c02_intro_R.html#lectura-escritura-de-datos-.csv-.xlsx-.rdata-.rds",
    "href": "c02_intro_R.html#lectura-escritura-de-datos-.csv-.xlsx-.rdata-.rds",
    "title": "3  Primeros pasos en R",
    "section": "3.6 Lectura / escritura de datos (.csv, .xlsx, .RData, .rds)",
    "text": "3.6 Lectura / escritura de datos (.csv, .xlsx, .RData, .rds)\nEn la pestaña en Entorno (Environment) de RStudio podemos importar conjuntos de datos o datasets con el asistente de importación. No es recomendable cuando debemos importar varios archivos o si se van a leer archivos grandes. Para lo cual es más eficiente usar código.\n\n\n3.6.1 CSV\nSi conocemos la estructura de nuestros datos (por ejemplo, la primera fila es el título de las columnas o es un archivo separado por comas), Se pueden utilizar las funciones read.csv (librería base) o read_csv (librería readr, de tidyverse):\n\n\nCode\n# datos será un 'data frame'\ndata01 <- read.csv(file = 'data/file.csv')\nhead(data01)\n\n\n  Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n1          5.1         3.5          1.4         0.2  setosa\n2          4.9         3.0          1.4         0.2  setosa\n3          4.7         3.2          1.3         0.2  setosa\n4          4.6         3.1          1.5         0.2  setosa\n5          5.0         3.6          1.4         0.2  setosa\n6          5.4         3.9          1.7         0.4  setosa\n\n\nCode\n# datos será un 'tibble'\ndata01 <- readr::read_csv(file = 'data/file.csv')\n\n\nRows: 150 Columns: 5\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (1): Species\ndbl (4): Sepal.Length, Sepal.Width, Petal.Length, Petal.Width\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n\nCode\ndata01\n\n\n# A tibble: 150 × 5\n   Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n          <dbl>       <dbl>        <dbl>       <dbl> <chr>  \n 1          5.1         3.5          1.4         0.2 setosa \n 2          4.9         3            1.4         0.2 setosa \n 3          4.7         3.2          1.3         0.2 setosa \n 4          4.6         3.1          1.5         0.2 setosa \n 5          5           3.6          1.4         0.2 setosa \n 6          5.4         3.9          1.7         0.4 setosa \n 7          4.6         3.4          1.4         0.3 setosa \n 8          5           3.4          1.5         0.2 setosa \n 9          4.4         2.9          1.4         0.2 setosa \n10          4.9         3.1          1.5         0.1 setosa \n# ℹ 140 more rows\n\n\nEn otros casos, cuando \";\" es utilizado como el separador de campo y \",\" para el punto decimal, se utiliza una variante de estas funciones.\n\n\nCode\n# datos será un 'data frame'\ndata02 <- read.csv(file = 'data/file.csv', sep = ',', header = T)\n\n\nLa escritura de datos se realiza de la siguiente manera:\n\n\nCode\nreadr::write_csv(x = data02, file = \"data/csv_data.csv\")\n\n\n\n\n3.6.2 EXCEL\nEs posible leer datos en la forma .xls o .xlsx. Existen distintos paquetes que nos permiten hacerlo:\n\nEl paquete readxl contiene la función read_excel.\nEl paquete xlsx y la función read.xlsx\n\n\n\nCode\n# datos será un 'data frame'\ndata03 <- readxl::read_xls(path = \"data/file.xls\", sheet = 1)\ndata03 <- xlsx::read.xlsx(file = \"data/file.xls\", 1)\n\n\nLa escritura de datos se realiza de la siguiente manera:\n\n\nCode\nxlsx::write.xlsx(\n  data03, \"data/xlsx_data.xlsx\", sheetName = \"Sheet1\", \n  col.names = TRUE, row.names = TRUE, append = FALSE\n)\n\n\n\n\n3.6.3 RDS\nR proporciona dos formatos de archivo propios para almacenar datos, .RDS y .RData . Los archivos RDS pueden almacenar un solo objeto R y los archivos RData pueden almacenar varios objetos R.\nPuede abrir un archivo RDS con readRDS:\n\n\nCode\ndata04 <- readRDS(\"data/file.RDS\")\n\n\nLa escritura de datos se realiza de la siguiente manera:\n\n\nCode\nsaveRDS(data04, file = \"data/rds_data.RDS\")\n\n\n\n\n3.6.4 RDATA\nLa escritura de estos datos se realiza de la siguiente manera:\n\n\nCode\na <- 1\nb <- 2\nc <- 3\nsave(a, b, c, file = \"data/stuff.RData\")\n\n\nPuede abrir un archivo RData con load:\n\n\nCode\nload(\"data/stuff.RData\")"
  },
  {
    "objectID": "c03_intro_R2.html#control-de-flujo-condicionales",
    "href": "c03_intro_R2.html#control-de-flujo-condicionales",
    "title": "4  Control de Flujo y funciones",
    "section": "4.1 Control de Flujo Condicionales",
    "text": "4.1 Control de Flujo Condicionales\nLa toma de decisiones es una parte importante de la programación. Esto se puede lograr en la programación R usando la nomenclatura condicional if else.\n\n4.1.1 If\n\n\nCode\nif (expresion) {\n  declaracion\n}\n\n\n\nSi expresion es TRUE, la instrucción se ejecuta. Pero si es FALSO, no pasa nada.\nAquí, expresion puede ser un vector lógico o numérico, pero solo se tiene en cuenta el primer elemento.\nEn el caso del vector numérico, cero se toma como FALSO, el resto como VERDADERO.\n\n\n\n4.1.2 If…Else\n\n\nCode\nif (expresion) {\n    declaracion1\n  }else{\n    declaracion2\n}\n\n\nLa parte else es opcional y solo se evalúa si expresion es FALSE. Es importante tener en cuenta que else debe estar en la misma línea que las llaves de cierre de la instrucción if.\n\n\nCode\nx <- 0\nif (x < 0) {\n  print(\"Numero negativo\")\n}else if (x > 0) {\n  print(\"Numero positivo\")\n} else {\n  print(\"Cero\")\n}\n\n\n\n\nCode\ntemp = [15, 22, 30]\nsuelo= [\"seco\", \"humedo\", \"charcos\"]\nvaltemp = temp[0]\nvalsuelo= suelo[2]\nif 12<= valtemp < 22 and valsuelo ==\"seco\": \n    print(\"Cielo despejado\")\n    \nelif valtemp == 22 or valsuelo == \"humedo\":\n    print(\"lluvia leve\")\n    \nelif valtemp > 22 and valsuelo==\"charcos\":\n      print(\"lluvia severa\")\n    \nelse: print(\" Faltan datos\")\n\n\n\n\nCode\ntemp <- c(15, 22, 30)\nsuelo <- c(\"seco\", \"humedo\", \"charcos\")\nvaltemp <- temp[1]\nvalsuelo <- suelo[3]\nif (valtemp %in% 12:22 & valsuelo ==\"seco\") {\n  print(\"\\nCielo despejado\")\n} else if (valtemp == 22 | valsuelo == \"humedo\"){\n  print(\"\\nlluvia leve\")\n} else if (valtemp > 22 & valsuelo==\"charcos\"){\n  print(\"\\nlluvia severa\")\n} else {\n  print(\"\\nFaltan datos\")\n  }"
  },
  {
    "objectID": "c03_intro_R2.html#control-de-flujo-de-iteradores",
    "href": "c03_intro_R2.html#control-de-flujo-de-iteradores",
    "title": "4  Control de Flujo y funciones",
    "section": "4.2 Control de Flujo de Iteradores",
    "text": "4.2 Control de Flujo de Iteradores\nLos bucles son una de las estructuras fundamentales en la programación. Los bucles permiten iterar sobre cada elemento en una secuencia, uno a la vez, y hacer algo con esos elementos.\n\n4.2.1 FOR\nUn bucle for es muy valioso cuando necesitamos iterar sobre una lista de elementos o un rango de números. Loop se puede usar para iterar sobre una lista, marco de datos, vector, matriz o cualquier otro objeto. Los tirantes y el corchete son obligatorios.\n\n\nCode\nfor (valor in secuencia)\n  {\n    cuerpo\n  }\n\n\n\n\nCode\n# Creando un vector de frutas\nfrutas <- c('Apple', 'Orange', 'Passion fruit', 'Banana')\n# Declarando el bucle for\nfor ( i in frutas){ \n print(i)\n}\n\n\n[1] \"Apple\"\n[1] \"Orange\"\n[1] \"Passion fruit\"\n[1] \"Banana\"\n\n\n\n\n4.2.2 WHILE\nUn bucle es una declaración que continúa ejecutándose mientras se cumple una condición. La sintaxis para un ciclo while es la siguiente:\n\n\nCode\nwhile (condición)\n  {\n    cuerpo\n  }\n\n\n\n\nCode\n# creando la expresión con valor 1\ninicio <- 1\n# Creando el loop\nwhile (inicio <= 5){\n  # Ver donde estamos\n  cat('Este es el ciclo número ', inicio)\n  # Agregar 1 a la variable inicio despues de cada iteracion\n  inicio <- inicio + 1\n  print(inicio)\n}\n\n\nEste es el ciclo número  1[1] 2\nEste es el ciclo número  2[1] 3\nEste es el ciclo número  3[1] 4\nEste es el ciclo número  4[1] 5\nEste es el ciclo número  5[1] 6\n\n\nOtros iteradores\n\nrepeat\ndo-while (*otros leguajes)\n\nControl de flujo * break, next"
  },
  {
    "objectID": "c03_intro_R2.html#funciones",
    "href": "c03_intro_R2.html#funciones",
    "title": "4  Control de Flujo y funciones",
    "section": "4.3 Funciones",
    "text": "4.3 Funciones\nLa noción de función está bastante de moda, pero transmite diferentes significados. Dos usos distintos:\n\nNoción matemática de una función: Proporcionar un mapeo entre conjuntos de elementos.\nUna explicación “funcional” explica un fenómeno natural en términos de sus objetivos o propósitos.\n\nEn programación, las funciones también proporcionan asignaciones, pero se las considera mejor como herramientas para resolver tareas. La programación de funciones requiere la identificación de tareas que se encontrarán y, por lo tanto, deben resolverse repetidamente (por nosotros mismos o por otros).\nLos argumentos de la función  especifican las entradas (o los datos, representados como objetos R) aceptados por una función. Cada argumento puede ser obligatorio u opcional (proporcionando valores predeterminados).\nEl  de la función generalmente usa las entradas proporcionadas por  para realizar la tarea para la cual se creó la función. Puede contener cantidades arbitrarias de código R (incluidas referencias a objetos R existentes y otras funciones). Por defecto, la función devuelve el resultado de su última expresión.\nAquí un ejemplo:\n\n\nCode\npower <- function(x, exp = 1) {\n  x^exp\n}"
  },
  {
    "objectID": "c03_intro_R2.html#paquetes-y-librerías",
    "href": "c03_intro_R2.html#paquetes-y-librerías",
    "title": "4  Control de Flujo y funciones",
    "section": "4.4 Paquetes y librerías",
    "text": "4.4 Paquetes y librerías\nLos paquetes de R amplían la funcionalidad de R al proporcionar funciones, datos y documentación adicionales.Están escritos por una comunidad mundial de usuarios de R y pueden ser instalados desde la interfaz gráfica de RStudio\nSolo tienes que instalar el paquete una vez, si desea actualizar un paquete previamente instalado a una versión más nueva, puede ir a la ventana de Ficheros en Packages > Update y seleccionar los paquetes que desea actualizar.\nNo podrá utilizar las funciones, los objetos y los archivos de ayuda de un paquete hasta que lo cargue con library(). Una vez que haya instalado un paquete, puede cargarlo con la función library():\n\n4.4.1 Diferencias entre paquetes y librerías\nEn el caso de la función library(), en muchas ocasiones existe la confusión entre un paquete y una librería, y podemos encontrarnos con gente llamando “librerías” a los paquetes.\nUna cosa es la función library() usada para cargar un paquete, y que se refiere al lugar en dónde el paquete es localizado, habitualmente una carpeta en nuestro ordenador, y otra un paquete que es una colección de funciones y datos empaquetados de forma conveniente.\nDicho de otra manera, y en palabras de Hadley Wickham, científico de datos en RStudio, y creador de la gran mayoría de paquetes del ecosistema tidyverse:\n\nDe igual manera, para recordar la diferencia es ejecutar la función library() sin argumentos. Esto nos proporcionará una lista de paquetes instalados en diferentes librerías en nuestro ordenador.\n\n\nCode\n# Install packages\ninstall.packages(\"tidyverse\")\n# Load packages\nlibrary(tidyverse)\n# You can also use \"pacman\" package to install\n#  an loading other packages\nif (!require(\"pacman\")) {\n  install.packages(\"pacman\")\n}\npacman::p_load(\n  tidyverse, formatR, knitr, rmdformats, pander, labelled, readxl, magrittr, kableExtra,\n  Lahman, datos\n)\n\n\nPara mayor información de R base, se recomienda la siguiente ."
  },
  {
    "objectID": "c04_tidyverse_1.html#dplyr-básico",
    "href": "c04_tidyverse_1.html#dplyr-básico",
    "title": "5  Manipulación de datos con tidyverse",
    "section": "5.1 Dplyr básico",
    "text": "5.1 Dplyr básico\nLa visualización es una herramienta importante para la generación de información, pero es raro obtener los datos exactamente como se necesitan. A menudo, necesitará crear algunas variables o resúmenes nuevos, o tal vez solo desee cambiar el nombre de las variables o reordenar las observaciones para que sea un poco más fácil trabajar con los datos. Para más detalles sobre cómo transformar sus datos es empleando el paquete dplyr\nPara explorar los verbos básicos de manipulación de datos de dplyr, usaremos la base de datos de zonas de amortiguamiento. Este marco de datos contiene. Los datos provienen de la Servicio Nacional de Áreas Naturales Protegidas (SERNANP)\n\n\nCode\n# datos será un 'data frame'\nz_amortiguamiento <- read_csv(file = 'data/zon_amortiguamiento.csv')\n\n\nNew names:\nRows: 80 Columns: 11\n── Column specification\n──────────────────────────────────────────────────────── Delimiter: \",\" chr\n(6): Codigo, Area_natur, Periodo, Base_legal, Base_leg00, Base_leg01 dbl (2):\n...1, Superficie date (3): Fecha_lega, Fecha_le00, Fecha_le01\nℹ Use `spec()` to retrieve the full column specification for this data. ℹ\nSpecify the column types or set `show_col_types = FALSE` to quiet this message.\n• `` -> `...1`\n\n\nCode\nhead(z_amortiguamiento)\n\n\n# A tibble: 6 × 11\n   ...1 Codigo Area_natur    Periodo Base_legal Fecha_lega Base_leg00 Fecha_le00\n  <dbl> <chr>  <chr>         <chr>   <chr>      <date>     <chr>      <date>    \n1     1 RC04   Ashaninka     2019-2… R.P. Nº 2… 2012-12-28 <NA>       1899-12-30\n2     2 BP03   de Pui Pui    2019-2… R.J. Nº 2… 2008-10-28 <NA>       1899-12-30\n3     3 RN12   Matsés        2023-2… R.P. Nº 0… 2014-02-27 <NA>       1899-12-30\n4     4 RN10   Allpahuayo M… 2022-2… R.J. Nº 1… 2007-07-24 <NA>       1899-12-30\n5     5 RN06   de Salinas y… 2016-2… R.J. Nº 0… 2007-04-26 <NA>       1899-12-30\n6     6 RN02   de Junín      2008-2… R.J. Nº 1… 2008-06-03 <NA>       1899-12-30\n# ℹ 3 more variables: Base_leg01 <chr>, Fecha_le01 <date>, Superficie <dbl>\n\n\nEn esta sección se muestran cinco funciones clave de dplyr que le permiten resolver la gran mayoría de sus desafíos de manipulación de datos:\n\nElija observaciones por sus valores (filter()).\nReordenar las filas (arrange()).\nElija las variables por sus nombres (select()).\nCrear nuevas variables con funciones de variables existentes (mutate()).\nColapsar muchos valores en un solo resumen (summarize())\n\nTodos estos se pueden usar junto con group_by(), que cambia el alcance de cada función de operar en todo el conjunto de datos a operar en él grupo por grupo. Estas seis funciones proporcionan los verbos para un lenguaje de manipulación de datos.\nTodos los verbos funcionan de manera similar:\n\nEl primer argumento es un data.frame(marco de datos).\nLos argumentos siguientes describen qué hacer con el marco de datos, utilizando los nombres de las variables (sin comillas).\nEl resultado es un nuevo dataframe.\n\nJuntas, estas propiedades hacen que sea fácil encadenar varios pasos simples para lograr un resultado complejo. Profundicemos y veamos cómo funcionan estos verbos.\n\n5.1.1 Filtrar filas con filter()\n\n\n\nFilter() te permite filtrar un subconjunto de observaciones según sus valores. El primer argumento es el nombre del data frame. El segundo y los siguientes argumentos son las expresiones que lo filtran.\nPor ejemplo, podemos seleccionar todas las ZA con una Superficie mayor a 400000.00 con:\n\n\nCode\ndplyr::filter(z_amortiguamiento, Superficie > 400000.00 )\n\n\n# A tibble: 7 × 11\n   ...1 Codigo Area_natur    Periodo Base_legal Fecha_lega Base_leg00 Fecha_le00\n  <dbl> <chr>  <chr>         <chr>   <chr>      <date>     <chr>      <date>    \n1    18 PN09   Cordillera A… 2017-2… R.P. Nº 0… 2011-04-14 <NA>       1899-12-30\n2    30 PN06   del Río Abis… 2014-2… R.J. Nº 2… 2006-09-27 <NA>       1899-12-30\n3    42 RN08   Pacaya-Samir… 2017-2… R.J. Nº 1… 2009-09-24 <NA>       1899-12-30\n4    51 RC02   El Sira       2015-2… R.P. Nº 0… 2009-02-27 <NA>       1899-12-30\n5    60 RP02   Subcuenca de… 2019-2… R.P. Nº 1… 2009-09-15 <NA>       1899-12-30\n6    66 PN11   Alto Purús    2019-2… R.P. Nº 2… 2012-12-28 <NA>       1899-12-30\n7    67 PN11   Alto Purús    2019-2… R.P. Nº 2… 2012-12-28 <NA>       1899-12-30\n# ℹ 3 more variables: Base_leg01 <chr>, Fecha_le01 <date>, Superficie <dbl>\n\n\nCuando ejecutas esa línea de código, dplyr ejecuta la operación de filtrado y devuelve un nuevo data frame. Las funciones de dplyr nunca modifican su input, por lo que si deseas guardar el resultado, necesitarás usar el operador de asignación, <-:\n\n\nCode\nfilter01 <- dplyr::filter(z_amortiguamiento,Superficie > 400000.00 )\n\n\nDe otro modo usar el operador “%>%” de la librería magrittr.\nR imprime los resultados o los guarda en una variable. Si desea hacer ambas cosas, puede envolver la tarea entre paréntesis:\n\n\nCode\n(filter02 <- dplyr::filter(z_amortiguamiento,Superficie > 400000.00))\n\n\n# A tibble: 7 × 11\n   ...1 Codigo Area_natur    Periodo Base_legal Fecha_lega Base_leg00 Fecha_le00\n  <dbl> <chr>  <chr>         <chr>   <chr>      <date>     <chr>      <date>    \n1    18 PN09   Cordillera A… 2017-2… R.P. Nº 0… 2011-04-14 <NA>       1899-12-30\n2    30 PN06   del Río Abis… 2014-2… R.J. Nº 2… 2006-09-27 <NA>       1899-12-30\n3    42 RN08   Pacaya-Samir… 2017-2… R.J. Nº 1… 2009-09-24 <NA>       1899-12-30\n4    51 RC02   El Sira       2015-2… R.P. Nº 0… 2009-02-27 <NA>       1899-12-30\n5    60 RP02   Subcuenca de… 2019-2… R.P. Nº 1… 2009-09-15 <NA>       1899-12-30\n6    66 PN11   Alto Purús    2019-2… R.P. Nº 2… 2012-12-28 <NA>       1899-12-30\n7    67 PN11   Alto Purús    2019-2… R.P. Nº 2… 2012-12-28 <NA>       1899-12-30\n# ℹ 3 more variables: Base_leg01 <chr>, Fecha_le01 <date>, Superficie <dbl>\n\n\n\n5.1.1.1 Comparaciones\nPara usar el filtrado de manera efectiva, debes saber cómo seleccionar las observaciones que deseas utilizando los operadores de comparación. R proporciona el conjunto estándar: >, >=, <, <=, != (no igual) y == (igual).\nCuando comienzas con R, el error más fácil de cometer es usar = en lugar de == cuando se busca igualdad. Cuando esto suceda, obtendrás un error informativo:\n\n\nCode\ndplyr::filter(z_amortiguamiento,Superficie > 400000.00)\n\n\n# A tibble: 7 × 11\n   ...1 Codigo Area_natur    Periodo Base_legal Fecha_lega Base_leg00 Fecha_le00\n  <dbl> <chr>  <chr>         <chr>   <chr>      <date>     <chr>      <date>    \n1    18 PN09   Cordillera A… 2017-2… R.P. Nº 0… 2011-04-14 <NA>       1899-12-30\n2    30 PN06   del Río Abis… 2014-2… R.J. Nº 2… 2006-09-27 <NA>       1899-12-30\n3    42 RN08   Pacaya-Samir… 2017-2… R.J. Nº 1… 2009-09-24 <NA>       1899-12-30\n4    51 RC02   El Sira       2015-2… R.P. Nº 0… 2009-02-27 <NA>       1899-12-30\n5    60 RP02   Subcuenca de… 2019-2… R.P. Nº 1… 2009-09-15 <NA>       1899-12-30\n6    66 PN11   Alto Purús    2019-2… R.P. Nº 2… 2012-12-28 <NA>       1899-12-30\n7    67 PN11   Alto Purús    2019-2… R.P. Nº 2… 2012-12-28 <NA>       1899-12-30\n# ℹ 3 more variables: Base_leg01 <chr>, Fecha_le01 <date>, Superficie <dbl>\n\n\nHay otro problema común que puedes encontrar al usar ==: los números de coma flotante. ¡Estos resultados pueden sorprenderte!\n\n\nCode\nsqrt(2)^2 == 2\n\n\n[1] FALSE\n\n\nCode\n1 / 49 * 49 == 1\n\n\n[1] FALSE\n\n\nLas computadoras usan aritmética de precisión finita (obviamente, NO pueden almacenar una cantidad infinita de dígitos), así que recuerda que cada número que observas es una aproximación. En lugar de confiar en ==, usa near() (cercano, en inglés):\n\n\nCode\nnear(sqrt(2)^2, 2)\n\n\n[1] TRUE\n\n\nCode\nnear(1 / 49 * 49, 1)\n\n\n[1] TRUE\n\n\n\n\n5.1.1.2 Operadores lógicos\nSi tienes múltiples argumentos para filter() estos se combinan con “y”: cada expresión debe ser verdadera para que una fila se incluya en el output. Para otros tipos de combinaciones necesitarás usar operadores Booleanos: & es “y”, | es “o”, y ! es “no”. La siguiente figura muestra el conjunto completo de operaciones Booleanas.\n\nEl siguiente código sirve para encontrar todas las areas iguales a 310242.10 o 1880.50:\n\n\nCode\ndplyr::filter(z_amortiguamiento, Superficie == 310242.10 | Superficie == 1880.50)\n\n\n# A tibble: 2 × 11\n   ...1 Codigo Area_natur    Periodo Base_legal Fecha_lega Base_leg00 Fecha_le00\n  <dbl> <chr>  <chr>         <chr>   <chr>      <date>     <chr>      <date>    \n1     5 RN06   de Salinas y… 2016-2… R.J. Nº 0… 2007-04-26 <NA>       1899-12-30\n2    52 SN03   Lagunas de M… 2015-2… R.P. Nº 2… 2015-10-29 <NA>       1899-12-30\n# ℹ 3 more variables: Base_leg01 <chr>, Fecha_le01 <date>, Superficie <dbl>\n\n\nEl orden de las operaciones es importante. No puedes escribir filter(z_amortiguamiento, Superficie == (310242.10 | 1880.50)). Si quieres saber si es uno u otro valor, se puede resolver con x %in% y (es decir, x en y). Esto seleccionará cada fila donde x es uno de los valores en y. Podríamos usarlo para reescribir el código de arriba:\n\n\nCode\ndplyr::filter(z_amortiguamiento, Superficie %in% c(310242.10, 1880.50))\n\n\n# A tibble: 2 × 11\n   ...1 Codigo Area_natur    Periodo Base_legal Fecha_lega Base_leg00 Fecha_le00\n  <dbl> <chr>  <chr>         <chr>   <chr>      <date>     <chr>      <date>    \n1     5 RN06   de Salinas y… 2016-2… R.J. Nº 0… 2007-04-26 <NA>       1899-12-30\n2    52 SN03   Lagunas de M… 2015-2… R.P. Nº 2… 2015-10-29 <NA>       1899-12-30\n# ℹ 3 more variables: Base_leg01 <chr>, Fecha_le01 <date>, Superficie <dbl>\n\n\nA veces puedes simplificar subconjuntos complicados al recordar la ley de De Morgan: !(x & y) es lo mismo que !x | !y, y !(x | y) es lo mismo que **!x & !y*. Por ejemplo, si deseas encontrar areas mayores a 26.2 y menores 8652.24 .\n\n\nCode\ndplyr::filter(z_amortiguamiento,!(Superficie > 8652.24  | Superficie < 26.2))\n\n\n# A tibble: 21 × 11\n    ...1 Codigo Area_natur   Periodo Base_legal Fecha_lega Base_leg00 Fecha_le00\n   <dbl> <chr>  <chr>        <chr>   <chr>      <date>     <chr>      <date>    \n 1     9 SH02   de la Pampa… 2016-2… R.P. N° 0… 2016-01-29 <NA>       1899-12-30\n 2    10 SH01   de Chacamar… 2002-2… R.J. Nº 4… 2002-12-20 <NA>       1899-12-30\n 3    13 SN04   de Ampay     2015-2… R.P. Nº 1… 2014-12-22 <NA>       1899-12-30\n 4    14 SN01   de Huayllay  2018-2… R.J. Nº 3… 2001-12-13 <NA>       1899-12-30\n 5    21 PN05   Cerros de A… 2012-2… R.P. N° 0… 2012-02-17 Ley N° 30… 2015-11-11\n 6    36 SN05   los Manglar… 2023-2… R.P. N° 0… 2017-02-28 <NA>       1899-12-30\n 7    37 RC05   Machiguenga  2023-2… R.P. N° 0… 2017-02-28 <NA>       1899-12-30\n 8    39 SN07   Pampa Hermo… 2022-2… R.P. Nº 2… 2012-12-28 <NA>       1899-12-30\n 9    40 RVS01  Laquipampa   2015-2… R.P. Nº 0… 2015-01-27 <NA>       1899-12-30\n10    41 RVS02  Los Pantano… 2016-2… R.J. Nº 3… 2001-12-28 <NA>       1899-12-30\n# ℹ 11 more rows\n# ℹ 3 more variables: Base_leg01 <chr>, Fecha_le01 <date>, Superficie <dbl>\n\n\n\n\n\n5.1.2 Reordenar las filas con arrange()\narrange()** funciona de manera similar afilter()` excepto que en lugar de seleccionar filas, cambia su orden. La función toma un dataframe** y un conjunto de nombres de columnas (o expresiones más complicadas) para ordenar según ellas. Si proporcionas más de un nombre de columna, cada columna adicional se utilizará para romper empates en los valores de las columnas anteriores:\n\n\nCode\narrange(z_amortiguamiento, Codigo)\n\n\n# A tibble: 80 × 11\n    ...1 Codigo Area_natur   Periodo Base_legal Fecha_lega Base_leg00 Fecha_le00\n   <dbl> <chr>  <chr>        <chr>   <chr>      <date>     <chr>      <date>    \n 1     2 BP03   de Pui Pui   2019-2… R.J. Nº 2… 2008-10-28 <NA>       1899-12-30\n 2    75 BP04   San Matias-… 2023-2… R.P. N° 2… 2015-11-27 <NA>       1899-12-30\n 3    53 BP05   de Pagaibam… 2017-2… R.J. Nº 3… 2001-12-13 <NA>       1899-12-30\n 4    77 BP06   Alto Mayo    2023-2… R.P. Nº 0… 2023-02-27 <NA>       1899-12-30\n 5    57 CC01   El Angolo    2019-2… R.P. N° 2… 2012-11-28 <NA>       1899-12-30\n 6    29 CC02   Sunchubamba  <NA>    R.J. Nº 3… 2001-12-13 <NA>       1899-12-30\n 7    26 PN01   de Cutervo   2017-2… R.P. Nº 1… 2009-09-24 <NA>       1899-12-30\n 8    56 PN02   de Tingo Ma… 2022-2… R.P. N° 0… 2017-03-31 <NA>       1899-12-30\n 9    24 PN03   del Manu     2019-2… R.P. Nº 0… 2013-05-22 <NA>       1899-12-30\n10    25 PN03   del Manu     2019-2… R.P. Nº 0… 2013-05-22 <NA>       1899-12-30\n# ℹ 70 more rows\n# ℹ 3 more variables: Base_leg01 <chr>, Fecha_le01 <date>, Superficie <dbl>\n\n\nUsa desc() para reordenar por una columna en orden descendente:\n\n\nCode\narrange(z_amortiguamiento, desc(Superficie))\n\n\n# A tibble: 80 × 11\n    ...1 Codigo Area_natur   Periodo Base_legal Fecha_lega Base_leg00 Fecha_le00\n   <dbl> <chr>  <chr>        <chr>   <chr>      <date>     <chr>      <date>    \n 1    18 PN09   Cordillera … 2017-2… R.P. Nº 0… 2011-04-14 <NA>       1899-12-30\n 2    42 RN08   Pacaya-Sami… 2017-2… R.J. Nº 1… 2009-09-24 <NA>       1899-12-30\n 3    51 RC02   El Sira      2015-2… R.P. Nº 0… 2009-02-27 <NA>       1899-12-30\n 4    67 PN11   Alto Purús   2019-2… R.P. Nº 2… 2012-12-28 <NA>       1899-12-30\n 5    30 PN06   del Río Abi… 2014-2… R.J. Nº 2… 2006-09-27 <NA>       1899-12-30\n 6    66 PN11   Alto Purús   2019-2… R.P. Nº 2… 2012-12-28 <NA>       1899-12-30\n 7    60 RP02   Subcuenca d… 2019-2… R.P. Nº 1… 2009-09-15 <NA>       1899-12-30\n 8    24 PN03   del Manu     2019-2… R.P. Nº 0… 2013-05-22 <NA>       1899-12-30\n 9    15 PN14   Sierra del … 2023-2… R.P. N° 2… 2016-11-07 <NA>       1899-12-30\n10    28 RN14   Pucacuro     2019-2… R.P. Nº 0… 2013-03-20 <NA>       1899-12-30\n# ℹ 70 more rows\n# ℹ 3 more variables: Base_leg01 <chr>, Fecha_le01 <date>, Superficie <dbl>\n\n\n\n\n5.1.3 Seleccionar columnas con select()\n\n\n\nNo es raro obtener conjuntos de datos con cientos de variables. En este caso, el primer desafío a menudo se reduce a las variables que realmente te interesan. select() te permite seleccionar rápidamente un subconjunto útil utilizando operaciones basadas en los nombres de las variables.\nEn este caso emplearemos select() para quedarnos con algunas columnas en específico:\n\n\nCode\n# Seleccionar columnas por nombre\ndplyr::select(z_amortiguamiento, Codigo, Area_natur)\n\n\n# A tibble: 80 × 2\n   Codigo Area_natur                      \n   <chr>  <chr>                           \n 1 RC04   Ashaninka                       \n 2 BP03   de Pui Pui                      \n 3 RN12   Matsés                          \n 4 RN10   Allpahuayo Mishana              \n 5 RN06   de Salinas y Aguada Blanca      \n 6 RN02   de Junín                        \n 7 RN01   Pampa Galeras Barbara D' Achille\n 8 SH04   Bosque de Pomac                 \n 9 SH02   de la Pampa de Ayacucho         \n10 SH01   de Chacamarca                   \n# ℹ 70 more rows\n\n\nCode\n# Seleccionar todas las columnas entre Codigo y Periodo (incluyente)\ndplyr::select(z_amortiguamiento, Codigo:Periodo)\n\n\n# A tibble: 80 × 3\n   Codigo Area_natur                       Periodo  \n   <chr>  <chr>                            <chr>    \n 1 RC04   Ashaninka                        2019-2023\n 2 BP03   de Pui Pui                       2019-2023\n 3 RN12   Matsés                           2023-2027\n 4 RN10   Allpahuayo Mishana               2022-2026\n 5 RN06   de Salinas y Aguada Blanca       2016-2020\n 6 RN02   de Junín                         2008-2012\n 7 RN01   Pampa Galeras Barbara D' Achille 2022-2026\n 8 SH04   Bosque de Pomac                  2017-2021\n 9 SH02   de la Pampa de Ayacucho          2016-2020\n10 SH01   de Chacamarca                    2002-2007\n# ℹ 70 more rows\n\n\nCode\n# Seleccionar todas las columnas excepto aquellas entre Codigo y Periodo (incluyente)\ndplyr::select(z_amortiguamiento, -(Codigo:Periodo))\n\n\n# A tibble: 80 × 8\n    ...1 Base_legal       Fecha_lega Base_leg00 Fecha_le00 Base_leg01 Fecha_le01\n   <dbl> <chr>            <date>     <chr>      <date>     <chr>      <date>    \n 1     1 R.P. Nº 239-201… 2012-12-28 <NA>       1899-12-30 R.P. N° 0… 2019-01-29\n 2     2 R.J. Nº 285-200… 2008-10-28 <NA>       1899-12-30 R.P. N° 0… 2019-01-29\n 3     3 R.P. Nº 054-201… 2014-02-27 <NA>       1899-12-30 R.P N° 32… 2022-12-29\n 4     4 R.J. Nº 159-200… 2007-07-24 <NA>       1899-12-30 R.P. N° 0… 2022-03-15\n 5     5 R.J. Nº 087-200… 2007-04-26 <NA>       1899-12-30 R.P. N° 2… 2016-09-14\n 6     6 R.J. Nº 145-200… 2008-06-03 <NA>       1899-12-30 <NA>       1899-12-30\n 7     7 R.J. Nº 331-200… 2001-12-13 <NA>       1899-12-30 R.P. N° 0… 2022-03-02\n 8     8 R.P. Nº 006-201… 2011-01-19 <NA>       1899-12-30 R.P. N° 9… 2017-03-31\n 9     9 R.P. N° 019-201… 2016-01-29 <NA>       1899-12-30 <NA>       1899-12-30\n10    10 R.J. Nº 466-200… 2002-12-20 <NA>       1899-12-30 <NA>       1899-12-30\n# ℹ 70 more rows\n# ℹ 1 more variable: Superficie <dbl>\n\n\nHay una serie de funciones auxiliares que puedes usar dentro de select():\n\nstarts_with(\"abc\"): coincide con los nombres que comienzan con “abc”.\nends_with(\"xyz\"): coincide con los nombres que terminan con “xyz”.\ncontains(\"ijk\"): coincide con los nombres que contienen “ijk”.\nmatches(\"(.)\\\\1\"): selecciona variables que coinciden con una expresión regular (regex). Esta en particular coincide con cualquier variable que contenga caracteres repetidos.\nnum_range(\"x\", 1:3): coincide con x1,x2 y x3.\n\nConsulta ?select para ver más detalles.\nselect() se puede usar para cambiar el nombre de las variables, pero rara vez es útil porque descarta todas las variables que no se mencionan explícitamente. En su lugar, utiliza rename(), que es una variante de select() que mantiene todas las variables que no se mencionan explícitamente:\n\n\nCode\nnames(z_amortiguamiento)\n\n\n [1] \"...1\"       \"Codigo\"     \"Area_natur\" \"Periodo\"    \"Base_legal\"\n [6] \"Fecha_lega\" \"Base_leg00\" \"Fecha_le00\" \"Base_leg01\" \"Fecha_le01\"\n[11] \"Superficie\"\n\n\nCode\n# new name = old name\ndf <- rename(z_amortiguamiento, \"Baselegal\" = Base_legal)\nnames(df)\n\n\n [1] \"...1\"       \"Codigo\"     \"Area_natur\" \"Periodo\"    \"Baselegal\" \n [6] \"Fecha_lega\" \"Base_leg00\" \"Fecha_le00\" \"Base_leg01\" \"Fecha_le01\"\n[11] \"Superficie\"\n\n\nOtra opción es usar select() junto con el auxiliar everything() (todo, en inglés). Esto es útil si tienes un grupo de variables que te gustaría mover al comienzo del data frame.\n\n\nCode\ndplyr::select(z_amortiguamiento, Superficie, everything())\n\n\n# A tibble: 80 × 11\n   Superficie  ...1 Codigo Area_natur   Periodo Base_legal Fecha_lega Base_leg00\n        <dbl> <dbl> <chr>  <chr>        <chr>   <chr>      <date>     <chr>     \n 1    325684.     1 RC04   Ashaninka    2019-2… R.P. Nº 2… 2012-12-28 <NA>      \n 2     45367.     2 BP03   de Pui Pui   2019-2… R.J. Nº 2… 2008-10-28 <NA>      \n 3    231398.     3 RN12   Matsés       2023-2… R.P. Nº 0… 2014-02-27 <NA>      \n 4     65957.     4 RN10   Allpahuayo … 2022-2… R.J. Nº 1… 2007-07-24 <NA>      \n 5    310242.     5 RN06   de Salinas … 2016-2… R.J. Nº 0… 2007-04-26 <NA>      \n 6    100858.     6 RN02   de Junín     2008-2… R.J. Nº 1… 2008-06-03 <NA>      \n 7     14531.     7 RN01   Pampa Galer… 2022-2… R.J. Nº 3… 2001-12-13 <NA>      \n 8      9291.     8 SH04   Bosque de P… 2017-2… R.P. Nº 0… 2011-01-19 <NA>      \n 9       429.     9 SH02   de la Pampa… 2016-2… R.P. N° 0… 2016-01-29 <NA>      \n10      1332.    10 SH01   de Chacamar… 2002-2… R.J. Nº 4… 2002-12-20 <NA>      \n# ℹ 70 more rows\n# ℹ 3 more variables: Fecha_le00 <date>, Base_leg01 <chr>, Fecha_le01 <date>\n\n\n\n\n5.1.4 Añadir nuevas variables con mutate()\n\n\n\nAdemás de seleccionar conjuntos de columnas existentes, a menudo es útil crear nuevas columnas en función de columnas existentes. Ese es el trabajo de mutate() (del inglés mutar o transformar).\nmutate() siempre agrega nuevas columnas al final de un conjunto de datos, así que comenzaremos creando un conjunto de datos más pequeño para que podamos ver las nuevas variables. Recuerda que cuando usas RStudio, la manera más fácil de ver todas las columnas es View().\n\n\nCode\nz_amortiguamiento_sl <- dplyr::select(\n  z_amortiguamiento,\n  Codigo:Periodo,\n  contains(\"leg\"),\n  Superficie\n)\n\nmutate(\n  z_amortiguamiento_sl,\n  area_ha = Superficie / 10000,\n  inicio_legal = str_split(Periodo, \"-\", simplify = TRUE)[,1],\n  fin_legal = str_split(Periodo, \"-\", simplify = TRUE)[,2]\n)\n\n\n# A tibble: 80 × 11\n   Codigo Area_natur         Periodo Base_legal Fecha_lega Base_leg00 Base_leg01\n   <chr>  <chr>              <chr>   <chr>      <date>     <chr>      <chr>     \n 1 RC04   Ashaninka          2019-2… R.P. Nº 2… 2012-12-28 <NA>       R.P. N° 0…\n 2 BP03   de Pui Pui         2019-2… R.J. Nº 2… 2008-10-28 <NA>       R.P. N° 0…\n 3 RN12   Matsés             2023-2… R.P. Nº 0… 2014-02-27 <NA>       R.P N° 32…\n 4 RN10   Allpahuayo Mishana 2022-2… R.J. Nº 1… 2007-07-24 <NA>       R.P. N° 0…\n 5 RN06   de Salinas y Agua… 2016-2… R.J. Nº 0… 2007-04-26 <NA>       R.P. N° 2…\n 6 RN02   de Junín           2008-2… R.J. Nº 1… 2008-06-03 <NA>       <NA>      \n 7 RN01   Pampa Galeras Bar… 2022-2… R.J. Nº 3… 2001-12-13 <NA>       R.P. N° 0…\n 8 SH04   Bosque de Pomac    2017-2… R.P. Nº 0… 2011-01-19 <NA>       R.P. N° 9…\n 9 SH02   de la Pampa de Ay… 2016-2… R.P. N° 0… 2016-01-29 <NA>       <NA>      \n10 SH01   de Chacamarca      2002-2… R.J. Nº 4… 2002-12-20 <NA>       <NA>      \n# ℹ 70 more rows\n# ℹ 4 more variables: Superficie <dbl>, area_ha <dbl>, inicio_legal <chr>,\n#   fin_legal <chr>\n\n\nSi solo quieres conservar las nuevas variables, usa transmute():\n\n\nCode\ntransmute(\n  z_amortiguamiento_sl,\n  area_ha = Superficie / 10000,\n  inicio_legal = str_split(Periodo, \"-\", simplify = TRUE)[,1],\n  fin_legal = str_split(Periodo, \"-\", simplify = TRUE)[,2]\n)\n\n\n# A tibble: 80 × 3\n   area_ha inicio_legal fin_legal\n     <dbl> <chr>        <chr>    \n 1 32.6    2019         2023     \n 2  4.54   2019         2023     \n 3 23.1    2023         2027     \n 4  6.60   2022         2026     \n 5 31.0    2016         2020     \n 6 10.1    2008         2012     \n 7  1.45   2022         2026     \n 8  0.929  2017         2021     \n 9  0.0429 2016         2020     \n10  0.133  2002         2007     \n# ℹ 70 more rows\n\n\n\n5.1.4.1 Funciones de creación útiles\nHay muchas funciones para crear nuevas variables que puedes usar con mutate(). La propiedad clave es que la función debe ser vectorizada: debe tomar un vector de valores como input, y devolver un vector con el mismo número de valores como output. No hay forma de enumerar todas las posibles funciones que podrías usar, pero aquí hay una selección de funciones que frecuentemente son útiles:\n\nOperadores aritméticos: +, -, *, /, ^. Todos están vectorizados usando las llamadas “reglas de reciclaje”. Si un parámetro es más corto que el otro, se extenderá automáticamente para tener la misma longitud. Esto es muy útil cuando uno de los argumentos es un solo número: Superficie / 100000, hours * 60 + minute, etc. Los operadores aritméticos también son útiles junto con las funciones de agregar que aprenderás más adelante. Por ejemplo, x / sum(x) calcula la proporción de un total, y y - mean(y) calcula la diferencia de la media.\nAritmética modular: %/% (división entera) y %% (resto), donde x == y * (x %/% y) + (x %% y). La aritmética modular es una herramienta útil porque te permite dividir enteros en partes.\nLogaritmos: log(), log2(), log10(). Los logaritmos son increíblemente útiles como transformación para trabajar con datos con múltiples órdenes de magnitud. También convierten las relaciones multiplicativas en aditivas, bastante empleados cuando se trabajan con modelos. En igualdad de condiciones, recomendamos usar log2() porque es más fácil de interpretar: una diferencia de 1 en la escala de registro corresponde a la duplicación de la escala original y una diferencia de -1 corresponde a dividir a la mitad.\nRezagos: lead() y lag() te permiten referirte a un valor adelante o un valor atrás (con rezago). Esto te permite calcular las diferencias móviles (por ejemplo, x - lag(x)) o encontrar cuándo cambian los valores (x! = lag (x)). Estos comandos son más útiles cuando se utilizan junto con group_by(), algo que aprenderás en breve.\n\n\n\nCode\n(x <- 1:10)\n\n\n [1]  1  2  3  4  5  6  7  8  9 10\n\n\nCode\nlag(x)\n\n\n [1] NA  1  2  3  4  5  6  7  8  9\n\n\nCode\nlead(x)\n\n\n [1]  2  3  4  5  6  7  8  9 10 NA\n\n\n\nAgregados acumulativos y móviles: R proporciona funciones para ejecutar sumas, productos, mínimos y máximos: cumsum(), cumprod(), cummin(), cummax(); dplyr, por su parte, proporciona cummean() para las medias acumuladas. Si necesitas calcular agregados móviles (es decir, una suma calculada en una ventana móvil), prueba el paquete RcppRoll.\n\n\n\nCode\nx\n\n\n [1]  1  2  3  4  5  6  7  8  9 10\n\n\nCode\ncumsum(x)\n\n\n [1]  1  3  6 10 15 21 28 36 45 55\n\n\nCode\ncummean(x)\n\n\n [1] 1.0 1.5 2.0 2.5 3.0 3.5 4.0 4.5 5.0 5.5\n\n\n\nComparaciones lógicas: <, <=, >, >=, !=. Si estás haciendo una secuencia compleja de operaciones lógicas, es a menudo una buena idea almacenar los valores provisionales en nuevas variables para que puedas comprobar que cada paso funciona como se espera.\n\n\n\n\n5.1.5 Resúmenes agrupados con summarise()\nEl último verbo clave es summarise() (resumir, en inglés). Se encarga de colapsar un data frame en una sola fila:\n\n\nCode\nsummarize(z_amortiguamiento, area_mean = mean(Superficie, na.rm = TRUE))\n\n\n# A tibble: 1 × 1\n  area_mean\n      <dbl>\n1   181865.\n\n\nEn caso se requiera categorizar una columna utilizaremos case_when() dentro de la función mutate().\nsummarise() no es muy útil a menos que lo enlacemos con group_by(). Esto cambia la unidad de análisis del conjunto de datos completo a grupos individuales. Luego, cuando uses los verbos dplyr en un data frame agrupado, estos se aplicarán automáticamente “por grupo”. Por ejemplo, si aplicamos exactamente el mismo código a un dataframe agrupado por fecha, obtenemos el retraso promedio por fecha:\n\n\nCode\nz_amortiguamiento_g <- mutate(z_amortiguamiento, \n       Grupo = case_when(\n         Superficie < 50000 ~ \"Grupo1\",\n         Superficie >= 50000 & Superficie <= 100000 ~ \"Grupo2\",\n         Superficie >= 100000 & Superficie <= 200000 ~ \"Grupo3\",\n         Superficie >= 200000 ~ \"Grupo4\"\n       ))\nby_group <- group_by(z_amortiguamiento_g, Grupo)\nsummarize(by_group, sup_mean = mean(Superficie, na.rm = TRUE))\n\n\n# A tibble: 4 × 2\n  Grupo  sup_mean\n  <chr>     <dbl>\n1 Grupo1   12494.\n2 Grupo2   68255.\n3 Grupo3  144261.\n4 Grupo4  513469.\n\n\nJuntos group_by() y summarise() proporcionan una de las herramientas que más comúnmente usarás cuando trabajes con dplyr: resúmenes agrupados. Pero antes de ir más allá con esto, tenemos que introducir una idea nueva y poderosa: el pipe (pronunciado /paip/, que en inglés significa ducto o tubería)."
  },
  {
    "objectID": "c04_tidyverse_1.html#combinación-de-múltiples-operaciones-con-el-pipe",
    "href": "c04_tidyverse_1.html#combinación-de-múltiples-operaciones-con-el-pipe",
    "title": "5  Manipulación de datos con tidyverse",
    "section": "5.2 Combinación de múltiples operaciones con el pipe",
    "text": "5.2 Combinación de múltiples operaciones con el pipe\nImagina que queremos agrupar por grupos y generar un resumen de cuántos elementos y la media de estos hay en cada uno de ellos.\nla relación entre la distancia y el atraso promedio para cada ubicación. Usando lo que sabes acerca de dplyr, podrías escribir un código como este:\n\n\nCode\nz_amortiguamiento_r <- z_amortiguamiento_g %>% \n  group_by(Grupo) %>% \n  summarise(\n    cantidad = n(),\n    sup_mean = mean(Superficie, na.rm = TRUE)\n  )\n\nggplot(data = z_amortiguamiento_r, mapping = aes(x = Grupo, y = cantidad)) +\n geom_col(aes(size = cantidad), alpha = 1/3) +\n geom_smooth(se = FALSE)\n\n\n`geom_smooth()` using method = 'loess' and formula = 'y ~ x'\n\n\n\n\n\nSe puede resumir en tres pasos para preparar la información:\n\nAgrupar los datos según el criterio a analizar.\nResumir para calcular la cantidad de cada grupo y el promedio por cada uno de ellos.\nFiltrar para eliminar datos ruidosos.\n\nLo que permite el uso del pipe es hacer una secuencia más fácil de leer. Se puede leer como una serie de declaraciones imperativas: agrupa, luego resume y luego filtra. Como sugiere esta lectura, una buena forma de pronunciar %>% cuando se lee el código es “luego”.\nLo que ocurre detrás del código, es que x %>% f(y) se convierte en f(x, y), y x %>% f(y) %>% g(z) se convierte en g(f(x, y), z) y así sucesivamente. Puedes usar el pipe para reescribir múltiples operaciones de forma que puedas leer de izquierda a derecha, de arriba hacia abajo. Usaremos pipes con frecuencia a partir de ahora porque mejora considerablemente la legibilidad del código.\nTrabajar con el pipe es uno de los criterios clave para pertenecer al tidyverse. La única excepción es ggplot2: se escribió antes de que se descubriera el pipe. Lamentablemente, la siguiente iteración de ggplot2, ggvis, que sí utiliza el pipe, aún no está lista para el horario estelar."
  }
]