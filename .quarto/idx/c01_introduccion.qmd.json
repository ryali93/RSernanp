{"title":"Introducción a R","markdown":{"headingText":"Introducción a R","containsRefs":false,"markdown":"\n## Instalación de R, RStudio y RTools\n\n### R y RStudio\n\n<p style=\"text-align: justify;\">\n\nPrimero deberá descargar e instalar R y luego RStudio.\n\n**Instalación de R**\n\nPara instalar R hay que bajar un fichero ejecutable de la página web del proyecto R: [**http://www.r-project.org/**](http://www.r-project.org/). Actualmente (Mayo 2021), la versión más reciente de R para el entorno Windows es la 4.1.0 y el ejecutable de tamaño aproximadamente 86Mb tiene el nombre R-4.1.0-win.exe.\n\n**Instalación de RStudio**\n\nPara instalar RStudio nos dirigimos al enlace <http://www.rstudio.org/>,la versión en pruebas es gratuita.Una vez bajado este ejecutable, hay que ejecutarlo y seguir las instrucciones del programa de instalación.\n\n</p>\n\n### RTools\n\n<p style=\"text-align: justify;\">\n\nEs un paquete de herramientas para construir paquetes de R. Esto es lo que desea para construir sus propios paquetes en Windows, o para construir R por sí mismo. A partir de **R 4.0.0** (lanzado en abril de 2020), R para Windows usa un paquete de cadena de herramientas llamado <u>rtools40</u>.\n\nEsta versión de <u>Rtools</u> incluye gcc 8.3.0 e introduce un nuevo sistema de compilación basado en [**msys2**\\`](https://www.msys2.org/), que facilita la compilación y el mantenimiento de R, así como las bibliotecas del sistema que necesitan los paquetes de R en Windows. Las compilaciones recientes de **rtools40** también contienen una cadena de herramientas adicional gcc-10 ucrt para probar paquetes de R y bibliotecas del sistema con las compilaciones ucrt experimentales de R-devel. Para obtener más información sobre estos temas, siga los enlaces al final de este documento.\n\n</p>\n\n<p style=\"text-align: justify;\">\n\nJeroen Ooms mantiene la versión actual de Rtools. El profesor Brian Ripley y Duncan Murdoch prepararon [**ediciones anteriores**](https://cran.r-project.org/bin/windows/Rtools/history.html). El mejor lugar para informar errores es a través de la organización [**r-windows**](https://github.com/r-windows) en GitHub.\n\n</p>\n\n## ¿Qué es R?\n\n<p style=\"text-align: justify;\">\n\nR es un lenguaje de programación y entorno computacional dedicado a la estadística.\n\nQue proporciona un amplio abanico de herramientas estadísticas (modelos lineales y no lineales, tests estadísticos, análisis de series temporales, algoritmos de clasificación y agrupamiento,etc.)\n\nPermite definir funciones propias. De hecho, gran parte de las funciones de R están escritas en el mismo R, aunque para algoritmos computacionalmente exigentes es posible desarrollar bibliotecas en C, C++ o Fortran que se cargan dinámicamente\n\nR puede integrarse con distintas bases de datos y existen bibliotecas que facilitan su utilización desde lenguajes de programación interpretados como Python (PythonInR),hereda de S su orientación a objetos.\n\nOtra de las características de R es su capacidad gráfica, que permite generar gráficos con alta calidad (ggplot). R posee su propio formato para la documentación basado en LaTeX.\n\n</p>\n\n<p align=\"center\">\n\n<img src=\"https://cran.r-project.org/Rlogo.svg\" width=\"300\"/>\n\n</p>\n\n## ¿Qué es RStudio?\n\n<p style=\"text-align: justify;\">\n\nRStudio es un editor para scripts disponible para usuarios de R en todos los sistemas operativos. Es considerado como un <u>entorno de desarrollo integrado (GUI)</u>que combina un interfaz muy intuitiva con herramientas de código muy potentes que permiten sacar el máximo provecho a R.\n\nLa ventaja de este editor es que ofrece una serie de opciones no existentes en R, entre otras, por ejemplo, comprobar rápidamente que ningún paréntesis queda sin cerrarse o marcar, copiar y pegar columnas.\n\nPero además nos da un listado de las variables y nos da una descripción de los bancos de datos que hemos introducido. También tiene una lista de los paquetes instalados y los gráficos realizados.\n\n</p>\n\n<p align=\"center\">\n\n<img src=\"fig/s01_rstudio_logo.png\" width=\"400\"/>\n\n</p>\n\n## ¿Qué otros IDE's existen para R?\n\n-   Tinn-R\n-   RKward\n-   Rcommander\n-   Jupyter notebook\n-   Visual studio code\n-   Pycharm\n-   Eclipse\n\n## Tipos de lenguajes de programación\n\n### Lenguaje compilado\n\n<p style=\"text-align: justify;\">\n\nSon aquellos lenguajes de alto nivel que como su nombre lo sugiere, requieren de un compilador (programa que traduce un lenguaje de alto nivel en código máquina o lenguaje máquina) para traducirlo y crear la parte ejecutable.\n\n</p>\n\n-   C++\n-   Go\n\n### Lenguaje interpretado\n\n<p style=\"text-align: justify;\">\n\nSon aquellos lenguajes de programación también de alto nivel en donde el código fuente debe ser traducido a un lenguaje que la máquina entienda y pueda realizar, no crean un archivo externo.\n\n</p>\n\n-   Ruby\n-   Javascript\n-   Python\n-   R\n\n<p style=\"text-align: justify;\">\n\nLos lenguajes de alto nivel permiten escribir instrucciones en un idioma muy parecido al inglés así como hacer uso de notaciones matemáticas comunes.\n\n</p>\n\n### Lenguaje intermedio\n\n<p style=\"text-align: justify;\">\n\nLos lenguajes intermedios son compilados hacia programas intermedios y luego interpretados, esto permite que pueda ser ejecutado desde cualquier sistema operativo sin necesidad de crear ejecutables.\n\n</p>\n\n-   Java\n-   C#\n\n<p align=\"center\">\n\n<img src=\"fig/s01_tipos_lenguaje.png\" width=\"600\"/>\n\n</p>\n\n## Paradigmas de programación\n\nUn paradigma de programación es una manera o estilo de programación de software. Se trata de un conjunto de métodos sistemáticos aplicables en todos los niveles del diseño de programas para resolver problemas computacionales.\n\n### Programación Orientado a Objetos\n\nSe construyen modelos de objetos que representan elementos (objetos) del problema a resolver, que tienen características y funciones. Permite separar los diferentes componentes de un programa, simplificando así su creación, depuración y posteriores mejoras. La programación orientada a objetos disminuye los errores y promociona la reutilización del código. Es una manera especial de programar, que se acerca de alguna manera a cómo expresaríamos las cosas en la vida real.\n\n### Programación Funcional\n\nLa programación funcional es un paradigma declarativo. Nos enfocaremos en \"qué\" estamos haciendo y no en \"cómo\" se está haciendo que sería el enfoque imperativo. Esto quiere decir que se expresa nuestra lógica sin describir controles de flujo, ni ciclos ni condicionales.\n\n<p align=\"center\">\n\n<img src=\"fig/s01_paradigmas.jpg\" width=\"600\"/>\n\n</p>\n\n## Ambiente de trabajo en RStudio\n\n<p style=\"text-align: justify;\">\n\nLa interfaz gráfica de RStudio nos permite acceder a scripts, datos, encontrar ayuda y previsualizar gráficos y resultados.\n\n</p>\n\n<p align=\"center\">\n\n<img src=\"fig/s01_rstudio_ide.png\" width=\"800\"/>\n\n</p>\n\n## Tipos de datos en R\n\n<p style=\"text-align: justify;\">\n\nR es capaz de manejar una variedad de tipos de datos, que se almacenan en diferentes estructuras como se puede observar en la siguiente tabla:\n\n</p>\n\n| Tipos de Datos |                                                                                                                                        Información                                                                                                                                        |                         Definición                          |\n|:--------------:|:-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------:|:-----------------------------------------------------------:|\n|   `Numeric`    |                                                                                                                  Datos contenidos en el conjuntos de los números reales                                                                                                                   |                        `num <- 3.14`                        |\n|   `Integer`    |                                                                                                                  Datos contenidos en el conjuntos de los números enteros                                                                                                                  |                         `int <- 3L`                         |\n|  `Character`   |                                                                                                                         Datos que soportan cadenas de caracteres                                                                                                                          |                   `chr <- \"hello world\"`                    |\n|   `Complex`    |                                                                                                                           Datos que soportan números complejos                                                                                                                            |                       `comp <- 3+2i`                        |\n|   `Logical`    |                                                                                                           Datos que sólo soportan valores lógicos de verdadero (T) o falso (F)                                                                                                            |                   `a <- 1; b <- 2; a < b`                   |\n|    `Factor`    | Este no es estrictamente un tipo de dato, pero vale la pena describirlo aquí. Una variable factor es una variable categórica. Los vectores de caracteres a menudo se almacenan como factores para explotar funciones para tratar datos categóricos. Por ejemplo, en análisis de regresión | Aplique `as.factor()` a un vector de caracteres o numéricos |\n\n## Tipos de estructuras de datos\n\n|   Objetos    |                             Tipos                             | ¿Soporta varios tipos de datos en el mismo objeto? |\n|:------------:|:-------------------------------------------------------------:|:--------------------------------------------------:|\n|   `Vector`   |             Numérico, carácter, complejo o lógico             |                         No                         |\n|   `Factor`   |                       Numérico o lógico                       |                         No                         |\n|  `Arreglo`   |             Numérico, carácter, complejo o lógico             |                         No                         |\n|   `Matriz`   |             Numérico, carácter, complejo o lógico             |                         No                         |\n| `Data frame` |             Numérico, carácter, complejo o lógico             |                         Sí                         |\n|     `ts`     |             Numérico, carácter, complejo o lógico             |                         Sí                         |\n|   `Lista`    | Numérico, carácter, complejo, lógico, función, expresión, ... |                         Sí                         |\n\n## Comience a codificar\n\n<p style=\"text-align: justify;\">\n\nComenzamos a codificar imprimiendo `Hello world`y posteriormente asignando valores a un objeto\n\n</p>\n\n```{r}\nprint(\"Hello world\")\n```\n\n### Asignación de objetos\n\n```{r}\n\nobj <- c(5, 2, 6, 58, 456, 56, 5)\nobj\nc(5, 2, 6, 58, 456, 56, 5) -> obj\nobj\n```\n\n## Conceptos Básicos de R\n\n### Vector\n\n-   Es el elemento más básico en R.\n-   Contiene elementos de la misma clase (son atómicos).\n-   Se crea con la función c(), que significa 'concatenar' o 'combinar'.\n\n```{r}\nvector01 <- c(1, 2, 4, 7, 10, 11, 12, 19, 26)\nvector01\nvector02 <- c(\"a\", \"b\", \"d\", \"g\", \"j\", \"k\", \"l\", \"s\", \"z\")\nvector02\nvector03 <- c(\"jorge\", \"roy\", \"daniel\", \"cesar\", \"patin\", 254, 265)\nvector03\nvector04 <- c(FALSE, FALSE, FALSE, TRUE, TRUE, TRUE, TRUE)\nvector04\n```\n\nAlgunas operaciones con vectores\n\n```{r}\n# indexar vectores\nvector01\nvector01[4]\n# evaluar la naturaleza del vector\na <- vector01[4]\nis.vector(a)\nis.numeric(a)\nis.integer(a)\n# operaciones con vectores\nlength(vector01)\n(vector01 * 2) + 500\nsum(vector01)\nsqrt(vector01 - 1)\nvector01 + (vector01 * 2)\n```\n\n### Factor\n\n<p style=\"text-align: justify;\">\n\nEn R, los factores se usan para trabajar con variables categóricas, es decir, variables que tienen un conjunto fijo y conocido de valores posibles. También son útiles cuando quieres mostrar vectores de caracteres en un orden no alfabético.\n\n</p>\n\n<p style=\"text-align: justify;\">\n\nHistóricamente, los factores eran más sencillos de trabajar que los caracteres. Como resultado, muchas de las funciones de R base automáticamente convierten los caracteres a factores. Esto significa que, a menudo, los factores aparecen en lugares donde no son realmente útiles. Afortunadamente, no tienes que preocuparte de eso con **tidyverse** y puedes concentrarte en situaciones en las que los factores son genuinamente útiles.\n\n</p>\n\n<p style=\"text-align: justify;\">\n\nSi quieres aprender más sobre factores, te recomendamos leer el artículo de Amelia McNamara y Nicholas Horton, [**Wrangling categorical data in R**](https://peerj.com/preprints/3163/) (el nombre significa Domando/Manejando Datos Categóricos en R). Este artículo cuenta parte de la historia discutida en [**stringsAsFactors: An unauthorized biography**](https://simplystatistics.org/2015/07/24/stringsasfactors-an-unauthorized-biography/) (del inglés cadenasComoFactores: Una Biografía No Autorizada) y [**stringsAsFactors =** <sigh>](https://notstatschat.tumblr.com/post/124987394001/stringsasfactors-sigh) (del inglés cadenasComoFactores = <suspiro>), y compara las propuestas tidy para los datos categóricos demostrados en este libro, en comparación a los métodos de R base. Una versión temprana de este artículo ayudó a motivar y definir el alcance del paquete forcats. ¡Gracias Amelia y Nick!\n\n</p>\n\nImagina que tienes una variable que registra meses:\n\n```{r}\nvect01 <- c(\"Dec\", \"Apr\", \"Jan\", \"Mar\", \"Jan\", \"Mar\")\n```\n\nUsar una cadena de caracteres (o string, en inglés) para guardar esta variable tiene dos problemas:\n\n1.  Solo hay doce meses posibles y no hay nada que te resguarde de errores de tipeo:\n\n```{r}\nvect02 <- c(\"Dec\", \"Apr\", \"Jam\", \"Mar\", \"Jan\", \"Mar\")\n```\n\n2.  No se ordena de una forma útil:\n\n```{r}\nsort(vect02)\n```\n\nPuedes solucionar ambos problemas con un `factor`. Para crearlo, debes empezar definiendo una lista con los niveles válidos:\n\n```{r}\nmonth_levels <- month.abb\n```\n\nAhora puedes crear un factor:\n\n```{r}\nfactor01 <- factor(vect01, levels = month_levels)\nfactor01\nsort(factor01)\n```\n\nCualquier valor no fijado en el conjunto será convertido a `NA` de forma silenciosa:\n\n```{r}\nfactor02 <- factor(vect02, levels = month_levels)\nfactor02\n```\n\nSi quieres una advertencia, puedes usar readr::parse_factor() (segmentar un factor, en inglés):\n\n```{r}\nreadr::parse_factor(vect02, levels = month_levels)\n```\n\nSi omites los niveles, se van a definir a partir de los datos en orden alfabético:\n\n```{r}\nfactor(vect01)\n```\n\nA veces es preferible que el orden de los niveles se corresponda con su primera aparición en los datos. Puedes hacer esto cuando creas el factor, al definir los niveles con `unique(x)` o después con `fct_inorder()`.\n\n```{r}\nfactor(vect01, levels = unique(vect01))\nforcats::fct_inorder(factor(vect01))\n```\n\n### Matrix\n\n<p style=\"text-align: justify;\">\n\nUna matriz es una `estructura bidimensional`. Las filas son horizontales y las columnas son verticales. `Una matriz de 4 por 3 (4 x 3), por ejemplo, tiene 4 filas y 3 columnas`. Las matrices se crean comúnmente usando tablas de datos numéricos como las de una hoja de cálculo de `Excel` o un archivo `csv`.\n\n</p>\n\n```{r}\nvector01\ndim(vector01)\n```\n\nDado que la variable es un vector, no tiene un atributo `dim` (entonces es simplemente NULL).\n\n¿Qué ocurre si le damos a `vector01` un atributo `dim`?\n\n```{r}\ndim(vector01) <- c(3, 3)\nvector01\nclass(vector01)\n```\n\n<p style=\"text-align: justify;\">\n\nEl ejemplo que utilizamos hasta ahora tenía la intención de ilustrar la idea de que una matriz es simplemente un vector con un atributo de dimensión.\n\n</p>\n\nUn método más directo para crear la misma matriz utiliza la función matrix.\n\n```{r}\nmatrix01 <- matrix(vector01, nrow = 3, ncol = 3, byrow = T)\nmatrix01\n```\n\n```{r}\narboles <- c(\"Tipuana tipu\", \"Myrsine andina\", \"Salix humboldtiana\")\nmatrix02 <- cbind(arboles, matrix01) # column bind o juntar por columna.\nmatrix02\n```\n\n<p style=\"text-align: justify;\">\n\nEsto se llama **coerción implícita** porque no lo hemos pedido. Solo sucedió. Sin embargo, todavía se desea trabajar con diferentes tipos de datos.\n\n</p>\n\n```{r}\nclass(matrix02)\ndim(matrix02)\nrownames(matrix02)\ncolnames(matrix02)\n```\n\n### Data Frame\n\n<p style=\"text-align: justify;\">\n\nUn data frame es una estructura de datos bidimensional similar a una matriz, pero funciona de manera muy diferente. Si bien un data frame parece una tabla simple, de hecho es una lista de vectores de la misma longitud. Para los nuevos usuarios de R, las matrices y los data frames parecen similares. La principal diferencia es que un data frame permite tipos de datos mixtos (por ejemplo, numérico, lógico, caracter). Esto les permite almacenar diferentes tipos de variables, lo cual es muy útil en el análisis estadístico. Por ejemplo, en un análisis de regresión. Las matrices se usan principalmente para almacenar datos numéricos, y se pueden usar para álgebra matricial.\n\n</p>\n\n<p style=\"text-align: justify;\">\n\nMatrices y Data Frames, ambos representan tipos de datos **rectangulares**, lo que significa que se usan para almacenar datos tabulares, con filas y columnas.\n\n</p>\n\n<p style=\"text-align: justify;\">\n\nLa principal diferencia, es que las **matrices** solo pueden contener una única clase de datos (al igual que los vectores), mientras que los **dataframes** pueden consistir de muchas clases diferentes de datos.\n\n</p>\n\n```{r}\n # se crea un data frame (df)\ndf01 <- data.frame(arboles, matrix01)\ndf01\nclass(df01)\n# podemos cambiar el nombre a las variables (columnas)\ncolnames(df01) <- c(\"nombre_cientifico\", \"circunferencia\", \"diametro_copa\", \"altura\" )\ndf01\n```\n\n#### Conjunto de datos en R\n\n<p style=\"text-align: justify;\">\n\nVarios conjuntos de datos tabulados o datasets se icluyen en la instalación de R (en el paquete datasets) y por defecto se ecuentran cargados para su uso. la funcion `data()` lista todos los `datasets de R`.\n\n</p>\n\nTrabajemos con el dataset `iris` **(Edgar Anderson's Iris Data)**\n\n```{r}\nstr(iris)\n# todas las observaciones de la columna 'Species'\niris[, \"Species\"]\n# Se utiliza el caracter ‘$’ para acceder a los campos o columnas.\niris$Species\n```\n\nCuando queremos extraer datos del data frame según una condicion, esto se complica.\n\n```{r}\nhead(iris[iris$Species == \"setosa\", ])\n```\n\n<p style=\"text-align: justify;\">\n\nAsí mismo, si se desea obtener las observaciones donde el ancho del sépalo sea menor o igual a 3 y la especie sea \"setosa\".\n\n</p>\n\n```{r}\nhead(iris[iris[, \"Sepal.Width\"] <= 3 & iris[, \"Species\"] == \"setosa\", ])\n```\n\n#### Subsetting\n\nLa función `subset` nos facilita filtrar datos cuando queremos que se cumplan ciertas condiciones.\n\n```{r}\nsubset(iris, Sepal.Width <= 3 & Species == \"setosa\")\n```\n\n**¿Pero es la mejor opción?** **¿Cómo ordeno?** **¿Cómo cambio de un formato \"ancho\" a un formato \"largo\" (o viceversa)? etc.**\n\nLa tendencia en la comunidad R para el tratamiento de datos, comprende el uso de [<u>**tidyverse**</u>](https://www.tidyverse.org/).\n\n### Listas\n\n<p style=\"text-align: justify;\">\n\nA diferencia de un vector, una lista es una colección de elementos que pueden ser de diferente tipo. Los componentes de una lista son típicamente pares **clave-valor (key-value)**. El siguiente ejemplo muestra cómo se puede almacenar un punto (con coordenas) en una lista.\n\n</p>\n\n```{r}\n# Los elementos de la lista generalmente se acceden por nombre\ncoordenadas <- list(x = 10, y = 15)\ncoordenadas\npoint <- list(id = 123, coord = coordenadas, spatial.reference = \"WGS_84\")\npoint\npoint$id\n# También podemos acceder a sus elementos de la siguiente manera\npoint[1]\nclass(point[1])\n# Para obtener el valor del elemento de la lista, use corchetes dobles\npoint[[1]]\nclass(point[[1]])\n```\n\n<p style=\"text-align: justify;\">\n\nLa lista, en el ejemplo, tiene tres elementos de diferentes tipos de datos. `id` es numérico, `coord` es otra lista y `spatial.reference` es una cadena de caracteres. La lista `coord` contiene dos elementos numéricos, `x` e `y`. Generalmente, se accede a los elementos de la lista usando su nombre, en lugar de número. En particular, muchas estructuras de datos tienen elementos con nombre a los que se puede acceder utilizando los operadores `$` o `@`.\n\n</p>\n"},"formats":{"html":{"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"knitr"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["styles.css"],"toc":true,"output-file":"c01_introduccion.html"},"language":{},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.2.269","editor":"visual","theme":"cosmo"},"extensions":{"book":{"multiFile":true}}}}}